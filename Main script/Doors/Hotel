if getgenv().keykami ~= "LLL" then
    game.Players.LocalPlayer:Kick("1.ËØ∑‰ΩøÁî®ÂÆòÊñπÂä†ËΩΩÂô®ËøõË°åÂä†ËΩΩÂç°ÂØÜ qqÁæ§Â∑≤Â§çÂà∂")
    setclipboard("1047677253")
    return
end
if not getgenv().LoaderVerifiedezlol then
game.Players.LocalPlayer:Kick("2.ËØ∑‰ΩøÁî®ÂÆòÊñπÂä†ËΩΩÂô®ËøõË°åÂä†ËΩΩ qqÁæ§Â∑≤Â§çÂà∂")
setclipboard("1047677253")
return
end
getgenv().keykami = nil
getgenv().LoaderVerifiedezlol = nil
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/wszzx2013/yezx/refs/heads/main/Obsidian%20ui/‰∏ªÈ¢ò"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/wszzx2013/yezx/refs/heads/main/Obsidian%20ui/ÈÖçÁΩÆ"))()
local ESPLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/mstudio45/MSESP/refs/heads/main/source.luau"))()

local notifysound = 4590657391
local PlayingSound = true
local EncodingService = game:GetService("EncodingService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Character = Player.Character
local Options = Library.Options
local Toggles = Library.Toggles
local UserInputService = game:GetService("UserInputService")
local IsMobile = UserInputService.TouchEnabled
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Lighting = game:GetService("Lighting")
local Fog = Lighting:FindFirstChild("Fog") or Lighting:FindFirstChild("CaveAtmosphere")
local RepStore = game:GetService("ReplicatedStorage")
local PS = game:GetService("Players")
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local PathfindingService = game:GetService("PathfindingService")
local RemoteFolder = ReplicatedStorage:FindFirstChild("RemotesFolder") or ReplicatedStorage:FindFirstChild("Bricks") or ReplicatedStorage:FindFirstChild("EntityInfo")
local Disable5 = not (hookmetamethod and newcclosure)
local MainGame = LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game
local RemoteListener = MainGame.RemoteListener
local Modules = RemoteListener.Modules
local dropRemote = RemoteFolder:WaitForChild("DropItem")
local ClientModules = ReplicatedStorage:FindFirstChild("ModulesClient") or ReplicatedStorage:FindFirstChild("ClientModules")
local Dread = Modules:FindFirstChild("Dread") or Modules:FindFirstChild("FuckYouDread")
local Screech = Modules:FindFirstChild("Screech") or Modules:FindFirstChild("FuckYouScreech")
local Halt = ClientModules.EntityModules:FindFirstChild("Shade") or ClientModules.EntityModules:FindFirstChild("FuckYouHalt")
Lighting.GlobalShadows = false

local Window = Library:CreateWindow({
    Title = "Yezx",
    Footer = "Doors: ÈÖíÂ∫ó",
    ToggleKeybind = Enum.KeyCode.RightShift,
    Center = true,
    AutoShow = true,
    ShowCustomCursor = false,
    MobileButtonsSide = "Left",
    Icon = 95759265059517,
})

local Tabs = {
    homeTab = Window:AddTab("È¶ñÈ°µ", "door-closed"),
    mainTab = Window:AddTab("‰∏ªË¶Å", "house"),
    exploitsTab = Window:AddTab("ÊºèÊ¥û", "bug"),
    ESPTab = Window:AddTab("ËßÜËßâ", "view"),
    infoTab = Window:AddTab("‰ø°ÊÅØ", "info"),
    floorTab = Window:AddTab("Ê•ºÂ±Ç", "sparkles"),
    ["UI Settings"] = Window:AddTab("ËÆæÁΩÆ", "settings"),
}

local AccountGroup = Tabs.homeTab:AddLeftGroupbox("Ë¥¶Êà∑")
local InfoGroup = Tabs.homeTab:AddRightGroupbox("‰ø°ÊÅØ")

local PlayerGroup = Tabs.mainTab:AddLeftGroupbox("Áé©ÂÆ∂")
local MiscGroup = Tabs.mainTab:AddLeftGroupbox("ÊùÇÈ°π")
local ReachGroup = Tabs.mainTab:AddRightGroupbox("Ëß¶Á¢∞")
local AutoGroup = Tabs.mainTab:AddRightGroupbox("Ëá™Âä®Âåñ")

local AntiEntityGroup = Tabs.exploitsTab:AddLeftGroupbox("Èò≤ÂÆû‰Ωì")
local BypassGroup = Tabs.exploitsTab:AddRightGroupbox("ÁªïËøá")

local ESPBox = Tabs.ESPTab:AddLeftTabbox("ËßÜËßâ")
local ESPSubTab = ESPBox:AddTab("ÈÄèËßÜ")
local SettingsSubTab = ESPBox:AddTab("ËÆæÁΩÆ")
local ESPMiscGroup = Tabs.ESPTab:AddLeftGroupbox("Ê∞õÂõ¥")
local NotifyBox = Tabs.ESPTab:AddRightTabbox("ÈÄöÁü•")
local NotifySubTab = NotifyBox:AddTab("ÈÄöÁü•")
local NotifySettingsSubTab = NotifyBox:AddTab("ËÆæÁΩÆ")
local CameraGroup = Tabs.ESPTab:AddRightGroupbox("ËßÜÈáé")

local FloorAntiEntityGroup = Tabs.floorTab:AddLeftGroupbox("Èò≤ÂÆû‰Ωì")
local MiscFloorGroup = Tabs.floorTab:AddRightGroupbox("ÊùÇÈ°π")

local devGroup = Tabs.infoTab:AddLeftGroupbox("ÂºÄÂèë‰∫∫Âëò")

Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local function GetBeijingTime()
    local localTime = os.date("*t")
    return string.format("%02d:%02d:%02d", localTime.hour, localTime.min, localTime.sec)
end

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter = FrameCounter + 1
    
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end
    
    local platformText = IsMobile and "ÊâãÊú∫" or IsConsole and "‰∏ªÊú∫" or "ÁîµËÑë"
    
    Library:SetWatermark(('yezx hub | %s | %s fps | %s ms | Êó∂Èó¥: %s'):format(
        platformText,
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue()),
        GetBeijingTime()
    ))
end)

local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("ËèúÂçïËÆæÁΩÆ")

MenuGroup:AddCheckbox("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "ÊòæÁ§∫ÈîÆ‰ΩçËèúÂçï",
    Callback = function(value)
        Library.KeybindFrame.Visible = value
    end,
})

if not IsMobile then
    MenuGroup:AddCheckbox("ShowCustomCursor", {
        Text = "Ëá™ÂÆö‰πâÂÖâÊ†á",
        Default = false,
        Callback = function(Value)
            Library.ShowCustomCursor = Value
        end,
    })
end

MenuGroup:AddDropdown("NotificationSide", {
    Values = { "Â∑¶‰æß", "Âè≥‰æß" },
    Default = "Âè≥‰æß",
    Text = "ÈÄöÁü•‰ΩçÁΩÆ",
    Callback = function(Value)
        Library:SetNotifySide(Value == "Â∑¶‰æß" and "Left" or "Right")
    end,
})

MenuGroup:AddDropdown("DPIDropdown", {
    Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
    Default = "100%",
    Text = "UIÂ§ßÂ∞è",
    Callback = function(Value)
        Value = Value:gsub("%%", "")
        local DPI = tonumber(Value)
        Library:SetDPIScale(DPI)
    end,
})

MenuGroup:AddDivider()
MenuGroup:AddLabel("ÈöêËóèUIÈîÆ‰Ωç")
    :AddKeyPicker("MenuKeybind", {
    Default = "RightShift", 
    NoUI = true, 
    Text = "Menu keybind"
})

MenuGroup:AddButton("Âç∏ËΩΩUI", function()
    getgenv().YezxExecuteCheck = false
    Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
ThemeManager:SetFolder("Yezx")
SaveManager:SetLibrary(Library)
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
SaveManager:SetFolder("Yezx")
SaveManager:SetSubFolder("Doors-Hotel")
ThemeManager:ApplyToTab(Tabs["UI Settings"])
SaveManager:BuildConfigSection(Tabs["UI Settings"])
SaveManager:LoadAutoloadConfig()

local function loadPlayerAvatar()
    local success, result = pcall(function()
        return game:GetService("Players"):GetUserThumbnailAsync(
            Player.UserId,
            Enum.ThumbnailType.HeadShot,
            Enum.ThumbnailSize.Size180x180
        )
    end)
    return success and result or nil
end

local avatarImage = AccountGroup:AddImage("UserAvatar", {
    Image = "rbxassetid://0",
    Height = 200,
    ScaleType = Enum.ScaleType.Fit,
    Transparency = 0
})

task.spawn(function()
    local avatarUrl = loadPlayerAvatar()
    if avatarUrl then
        avatarImage:SetImage(avatarUrl)
    else
        local initial = string.sub(Player.Name, 1, 1):upper()
        AccountGroup:AddLabel("Â§¥ÂÉèÂä†ËΩΩÂ§±Ë¥•")
        AccountGroup:AddLabel("‰Ω†Â•Ω: " .. initial)
    end
end)

AccountGroup:AddLabel("‰Ω†Â•Ω, "..Player.DisplayName.."! \nÊ¨¢Ëøé‰ΩøÁî®yezx!!!")
AccountGroup:AddLabel("‰Ω†ÁöÑÂÆ¢Êà∑Á´Øid:"..game:GetService("RbxAnalyticsService"):GetClientId())
AccountGroup:AddLabel("‰Ω†ÁöÑË¥¶Âè∑Âπ¥ÈæÑ:"..game.Players.LocalPlayer.AccountAge.."Â§©")
AccountGroup:AddLabel("‰Ω†ÁöÑË¥¶Âè∑ID:"..game.Players.LocalPlayer.UserId)

local platformInfo = IsMobile and "üü¢ ÊâãÊú∫" or IsConsole and "üî¥ ‰∏ªÊú∫" or "üü¢ ÁîµËÑë"
InfoGroup:AddLabel("Âπ≥Âè∞: " .. platformInfo)
InfoGroup:AddLabel("üü¢ÂèØ‰ΩøÁî®üî¥ÈîôËØØüü°‰øÆÂ§çüîµÂà∂‰Ωú‰∏≠\nüü£Êõ¥Êñ∞‚ö´Ô∏èÈîôËØØ‰∏çÊõ¥Êñ∞")
InfoGroup:AddLabel("ÁõÆÂâçÊîØÊåÅÊúçÂä°Âô®:")
InfoGroup:AddLabel("üü¢ ÈÄöÁî®")
InfoGroup:AddLabel("üîµ Doors (Èó®)")
InfoGroup:AddLabel("ÂΩìÂâçÊúçÂä°Âô®id:"..game.PlaceId)
InfoGroup:AddLabel("ÂΩìÂâçÊ∏∏Êàè:"..game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name)

local executorName = "Êú™Áü•"
local success, result = pcall(function()
    return identifyexecutor and identifyexecutor() or "Êú™Áü•"
end)
if success then 
    executorName = result 
end
InfoGroup:AddLabel("‰Ω†ÁöÑÊ≥®ÂÖ•Âô®:"..executorName)

local BypassDelay = PlayerGroup:AddSlider("BypassDelay", {
    Text = "ÈÄüÂ∫¶ÊóÅË∑ØÂª∂Ëøü",
    Default = 0.216,
    Min = 0.2,
    Max = 0.23,
    Rounding = 3,
    Callback = function(Value)
        _G.Delay = Value
    end
})

PlayerGroup:AddDivider()

local SpeedToggle = PlayerGroup:AddCheckbox("SpeedHack", {
    Text = "ÂêØÁî®ÈÄüÂ∫¶",
    Default = false,
    Callback = function(Value)
        _G.speedhack = Value
        if Value then
            startMovementLoop()
            updateMovement()
        else
            if _G.movementLoop then
                _G.movementLoop:Disconnect()
                _G.movementLoop = nil
            end
            updateMovement()
        end
    end
})

local SpeedSlider = PlayerGroup:AddSlider("WalkSpeed", {
    Text = "ÈÄüÂ∫¶",
    Default = 15,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        if _G.speedhack then 
            updateMovement() 
        end
    end
})

local NoAccelerationToggle = PlayerGroup:AddCheckbox("NoAcceleration", {
    Text = "Âç≥Êó∂Âä†ÈÄü",
    Default = false,
    Callback = function(Value)
        if Value then
            _G.NoAcceleration:Enable()
        else
            _G.NoAcceleration:Disable()
        end
    end
})

local EnableJumpToggle = PlayerGroup:AddCheckbox("EnableJump", {
    Text = "ÂêØÁî®Ë∑≥Ë∑É",
    Default = false,
    Callback = function(Value)
        if Player.Character then
            Player.Character:SetAttribute("CanJump", Value)
        end
    end
})

local InfiniteJumpToggle = PlayerGroup:AddCheckbox("InfiniteJump", {
    Text = "Êó†ÈôêË∑≥Ë∑É",
    Default = false
})

PlayerGroup:AddDivider()

local InstantPromptToggle = PlayerGroup:AddCheckbox("InstantPrompt", {
    Text = "Âç≥Êó∂‰∫íÂä®",
    Default = false,
    Callback = function(Value)
        if Value then
            for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
                if v:IsA("ProximityPrompt") then
                    v:SetAttribute("Hold", v.HoldDuration)
                    v.HoldDuration = 0
                end
            end
        else
            for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
                if v:IsA("ProximityPrompt") then
                    v.HoldDuration = v:GetAttribute("Hold") or 0.7
                end
            end
        end
    end
})

local NoClosetExitDelayToggle = PlayerGroup:AddCheckbox("NoClosetExitDelay", {
    Text = "Êó†Ë°£ÊüúÈÄÄÂá∫Âª∂Ëøü",
    Default = false
})

local AntiAFKToggle = PlayerGroup:AddCheckbox("AntiAFK", {
    Text = "Èò≤ÊåÇÊú∫",
    Default = false
})

PlayerGroup:AddDivider()

local Noclip = {}
Noclip.Enabled = false
Noclip.Connection = nil

function Noclip.Enable()
    if Noclip.Enabled then return end
    Noclip.Enabled = true
    
    Noclip.Connection = RunService.Stepped:Connect(function()
        if not LocalPlayer.Character then return end
        
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") and part.CanCollide then
                part.CanCollide = false
            end
        end
    end)
end

function Noclip.Disable()
    if not Noclip.Enabled then return end
    Noclip.Enabled = false
    
    if Noclip.Connection then
        Noclip.Connection:Disconnect()
        Noclip.Connection = nil
    end
    
    if LocalPlayer.Character then
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

function Noclip.Toggle()
    if Noclip.Enabled then
        Noclip.Disable()
    else
        Noclip.Enable()
    end
end

local NoclipToggle = PlayerGroup:AddCheckbox("Noclip", {
    Text = "Á©øÂ¢ô",
    Default = false,
    Callback = function(Value)
        if Value then
            Noclip.Enable()
        else
            Noclip.Disable()
        end
    end
})

local NoclipKeybind = NoclipToggle:AddKeyPicker("NoclipKeybind", {
    Default = "N",
    Modes = "Always", "Toggle", "Hold",
    Mode = "Toggle",
    Text = "Á©øÂ¢ô",
    SyncToggleState = true,
    Callback = function(Value)
    end
})

local Fly = {}
Fly.Enabled = false
Fly.Speed = 15
Fly.BodyVelocity = nil
Fly.BodyGyro = nil
Fly.Connection = nil

function Fly.Setup()
    if not LocalPlayer.Character then return end
    
    local HumanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    Fly.Cleanup()
    
    Fly.BodyVelocity = Instance.new("BodyVelocity")
    Fly.BodyVelocity.Name = "FlyBodyVelocity"
    Fly.BodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000)
    Fly.BodyVelocity.Velocity = Vector3.zero
    Fly.BodyVelocity.P = 1250
    Fly.BodyVelocity.Parent = HumanoidRootPart
    
    Fly.BodyGyro = Instance.new("BodyGyro")
    Fly.BodyGyro.Name = "FlyBodyGyro"
    Fly.BodyGyro.MaxTorque = Vector3.new(40000, 40000, 40000)
    Fly.BodyGyro.P = 1250
    Fly.BodyGyro.CFrame = HumanoidRootPart.CFrame
    Fly.BodyGyro.Parent = HumanoidRootPart
    
    local Humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if Humanoid then
        Humanoid.PlatformStand = true
    end
end

function Fly.Cleanup()
    if Fly.BodyVelocity then
        Fly.BodyVelocity:Destroy()
        Fly.BodyVelocity = nil
    end
    if Fly.BodyGyro then
        Fly.BodyGyro:Destroy()
        Fly.BodyGyro = nil
    end
    
    if LocalPlayer.Character then
        local Humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if Humanoid then
            Humanoid.PlatformStand = false
        end
        
        local HumanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if HumanoidRootPart then
            local oldBV = HumanoidRootPart:FindFirstChild("FlyBodyVelocity")
            local oldBG = HumanoidRootPart:FindFirstChild("FlyBodyGyro")
            if oldBV then oldBV:Destroy() end
            if oldBG then oldBG:Destroy() end
        end
    end
end

function Fly.Control()
    if not Fly.Enabled or not LocalPlayer.Character then return end
    
    local HumanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart or not Fly.BodyVelocity or not Fly.BodyGyro then return end
    
    local Camera = workspace.CurrentCamera
    if not Camera then return end
    
    local MoveDirection = Vector3.zero
    
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
        MoveDirection = MoveDirection + Camera.CFrame.LookVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        MoveDirection = MoveDirection - Camera.CFrame.LookVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
        MoveDirection = MoveDirection - Camera.CFrame.RightVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
        MoveDirection = MoveDirection + Camera.CFrame.RightVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
        MoveDirection = MoveDirection + Vector3.new(0, 1, 0)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
        MoveDirection = MoveDirection - Vector3.new(0, 1, 0)
    end
    
    if MoveDirection.Magnitude > 0 then
        Fly.BodyVelocity.Velocity = MoveDirection.Unit * Fly.Speed
    else
        Fly.BodyVelocity.Velocity = Vector3.zero
    end
    
    Fly.BodyGyro.CFrame = Camera.CFrame
end

function Fly.Enable()
    if Fly.Enabled then return end
    
    Fly.Enabled = true
    Fly.Setup()
    
    Fly.Connection = RunService.Heartbeat:Connect(function()
        Fly.Control()
    end)
end

function Fly.Disable()
    if not Fly.Enabled then return end
    
    Fly.Enabled = false
    
    if Fly.Connection then
        Fly.Connection:Disconnect()
        Fly.Connection = nil
    end
    
    Fly.Cleanup()
end

function Fly.Toggle()
    if Fly.Enabled then
        Fly.Disable()
    else
        Fly.Enable()
    end
end

function Fly.SetSpeed(NewSpeed)
    Fly.Speed = NewSpeed
end

LocalPlayer.CharacterAdded:Connect(function(Character)
    if Fly.Enabled then
        task.wait(1)
        Fly.Setup()
    end
end)

LocalPlayer.CharacterRemoving:Connect(function()
    if Fly.Enabled then
        Fly.Cleanup()
    end
end)

local FlyToggle = PlayerGroup:AddCheckbox("Fly", {
    Text = "È£ûË°å",
    Default = false,
    Callback = function(Value)
        if Value then
            Fly.Enable()
        else
            Fly.Disable()
        end
    end
})

local FlySpeedSlider = PlayerGroup:AddSlider("FlySpeed", {
    Text = "È£ûË°åÈÄüÂ∫¶",
    Default = 15,
    Min = 10,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        Fly.SetSpeed(Value)
    end
})

local FlyKeybind = FlyToggle:AddKeyPicker("FlyKeybind", {
    Default = "F",
    NoUI = false,
    Modes = "Always", "Toggle", "Hold",
    Mode = "Toggle",
    Text = "È£ûË°å",
    SyncToggleState = true,
    Callback = function(Value)
    end
})

local ResetButton = MiscGroup:AddButton({
    Text = "ÈáçÁΩÆ",
    DoubleClick = true,
    Func = function()
        if Disable4 == false then
            replicatesignal(LocalPlayer.Kill)
        elseif Disable4 == true then
            LocalPlayer.Character.Humanoid.Health = 0
        end
    end
})
local PlayAgainButton = MiscGroup:AddButton({
    Text = "ÂÜçÁé©‰∏ÄÊ¨°",
    DoubleClick = true,
    Func = function()
        RemoteFolder.PlayAgain:FireServer()
    end
})
local LobbyButton = MiscGroup:AddButton({
    Text = "ËøîÂõûÂ§ßÂéÖ",
    DoubleClick = true,
    Func = function()
        RemoteFolder.Lobby:FireServer()
    end
})
local ReviveButton = MiscGroup:AddButton({
    Text = "Â§çÊ¥ª",
    DoubleClick = true,
    Func = function()
        RemoteFolder.Revive:FireServer()
    end
})
local Disable4 = false
if not replicatesignal then
    Disable4 = true
end

local PromptClipToggle = ReachGroup:AddCheckbox("PromptClip", {
    Text = "ÊèêÁ§∫Á©øÈÄè",
    Default = false,
    Callback = function(Value)
        if Value then
            for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
                if v:IsA("ProximityPrompt") then
                    v.RequiresLineOfSight = false
                end
            end
        else
            for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
                if v:IsA("ProximityPrompt") then
                    v.RequiresLineOfSight = true
                end
            end
        end
    end
})
local DoorReachToggle = ReachGroup:AddCheckbox("DoorReach", {
    Text = "Èó®‰∫§‰∫íË∑ùÁ¶ª",
    Default = false
})

local DoorReachRange = ReachGroup:AddSlider("DoorReachRange", {
    Text = "Èó®‰∫§‰∫íË∑ùÁ¶ªËåÉÂõ¥",
    Default = 20,
    Min = 15,
    Max = 30,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.DoorReachRange = Value
    end
})

local AutoInteractTable = {}
local Ignore = {
    HidePrompt = true,
    RiftPrompt = true,
    StarRiftPrompt = true,
    InteractPrompt = true,
    FakePrompt = true,
    PushPrompt = true,
    ClimbPrompt = true,
    RevivePrompt = true,
    PropPrompt = true,
    NoHidingLilBro = true,
    DonatePrompt = true
}

local AutoInteractToggle = AutoGroup:AddCheckbox("AutoInteract", {
    Text = "Ëá™Âä®‰∫íÂä®",
    Default = false,
    Callback = function(Value)
        if Value then
            for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
                if not Ignore[v.Name] then
                    if v:IsA("ProximityPrompt") then
                        table.insert(AutoInteractTable, v)
                    end
                end
            end
        else
            table.clear(AutoInteractTable)
        end
    end
}):AddKeyPicker("AutoInteractKeybind", {
    Default = "R",
    Text = "Ëá™Âä®‰∫íÂä®",
    Modes = "Always", "Toggle", "Hold",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function(Value)
    end
})


local IgnoreListDropdown = AutoGroup:AddDropdown("IgnoreList", {
    Values = {"Êù∞Â§´ÂïÜÂ∫ó", "ÈáëÂ∏Å", "‰∏¢ÂºÉÁâ©", "Áª∑Â∏¶", "ÁÆ±Â≠ê", "ÁîµÊ±†"},
    Default = 1,
    Multi = true,
    Text = "ÂøΩÁï•ÂàóË°®",
    Callback = function(Value)
    end
})

AutoGroup:AddDivider()

local AutoHeartbeatToggle = AutoGroup:AddCheckbox("AutoHeartbeat", {
    Text = "Ëá™Âä®ÂøÉË∑≥Â∞èÊ∏∏Êàè",
    Default = false,
    Disabled = Disable5
})

AutoGroup:AddDivider()

local UnlockDistance = 40

AutoGroup:AddSlider('UnlockPadLockDistance', {
	Text = 'Ëß£ÈîÅÂõæ‰π¶È¶ÜÊåÇÈîÅË∑ùÁ¶ª',
	Min = 40, Max = 100, Default = 40,
	Rounding = 1,
	Callback = function(v)
		UnlockDistance = v
	end
})

local function findPL()
	return RemoteFolder:FindFirstChild("PL")
end

local PL = findPL()

local function parsePaper(paper, hintsContainer)
	local children = paper:WaitForChild("UI"):GetChildren()
	local map, order = {}, {}
	for i = 1, #children do
		local c = children[i]
		local idx = tonumber(c.Name)
		if idx then
			local key = c.ImageRectOffset.X .. "_" .. c.ImageRectOffset.Y
			map[key] = { idx, "" }
			order[idx] = key
		end
	end
	if hintsContainer then
		for _, ic in ipairs(hintsContainer:GetChildren()) do
			if ic.Name == "Icon" then
				local key = ic.ImageRectOffset.X .. "_" .. ic.ImageRectOffset.Y
				local entry = map[key]
				if entry then
					local lbl = ic:FindFirstChildWhichIsA("TextLabel")
					if lbl then entry[2] = lbl.Text end
				end
			end
		end
	end
	local parts = {}
	for i = 1, #order do
		parts[i] = map[ order[i] ][2]
	end
	return table.concat(parts)
end

local function manageToggle(toggleName, mode,place)
	local seenPapers = {}
	local lastCodes = {}
	local lastFireTimes = {}
	local padPart
	local conns = {}
	local enabled = false

	local function disconnectAll()
		for _, c in ipairs(conns) do
			if c.Disconnect then c:Disconnect() end
		end
		conns = {}
	end

	local function updatePad()
		local idx = RepStore.GameData.LatestRoom.Value
		local roomRoot = workspace.CurrentRooms and workspace.CurrentRooms[idx]
		if roomRoot then
			local pad = roomRoot:FindFirstChild("Padlock", true)
			padPart = pad and (pad.PrimaryPart or pad:FindFirstChildWhichIsA("BasePart"))
		else
			padPart = nil
		end
	end

	local function handleCode(paper)
		local hints = PlayerGui:FindFirstChild("PermUI") and PlayerGui.PermUI:FindFirstChild("Hints")
		local code = parsePaper(paper, hints)
		if lastCodes[paper] ~= code and code ~= "" then
			lastCodes[paper] = code
			if mode == "Fire" then
				if padPart and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
					local dist = (LocalPlayer.Character.HumanoidRootPart.Position - padPart.Position).Magnitude
					if dist <= UnlockDistance then
						local now = tick()
						if not lastFireTimes[code] or now - lastFireTimes[code] > 1 then
							local ok = pcall(function() if PL then PL:FireServer(code) end end)
							if ok then lastFireTimes[code] = now end
						end
					end
				end
			else
				Library:Notify("Âõæ‰π¶È¶Ü‰ª£Á†ÅÊòØ "..code, 3)
			end
		end
	end

	local function addPaper(paper)
		if seenPapers[paper] then return end
		seenPapers[paper] = true
		conns[#conns+1] = paper.DescendantAdded:Connect(function()
			handleCode(paper)
		end)
		conns[#conns+1] = paper.DescendantRemoving:Connect(function()
			handleCode(paper)
		end)
		handleCode(paper)
	end

	local function removePaper(paper)
		seenPapers[paper] = nil
		lastCodes[paper] = nil
	end

	place:AddCheckbox(toggleName, {
		Text = (mode == "Fire") and "Ëá™Âä®Âõæ‰π¶È¶Ü‰ª£Á†Å" or "ÈÄöÁü•Âõæ‰π¶È¶Ü‰ª£Á†Å",
		Default = false,
		Callback = function(on)
			enabled = on
			disconnectAll()
			table.clear(seenPapers)
			table.clear(lastCodes)
			table.clear(lastFireTimes)

			if enabled then
				while RepStore.GameData.LatestRoom.Value < 50 do
					task.wait(0.4)
					if not enabled then return end
				end

				updatePad()
				conns[#conns+1] = RepStore.GameData.LatestRoom:GetPropertyChangedSignal("Value"):Connect(updatePad)

				local function scanContainer(container)
					for _, obj in ipairs(container:GetChildren()) do
						if obj.Name == "LibraryHintPaper" or obj.Name == "LibraryHintPaperHard" then
							addPaper(obj)
						end
					end
				end

				local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
				scanContainer(char)
				scanContainer(LocalPlayer.Backpack)

				conns[#conns+1] = char.ChildAdded:Connect(function(obj)
					if obj.Name == "LibraryHintPaper" or obj.Name == "LibraryHintPaperHard" then
						addPaper(obj)
					end
				end)
				conns[#conns+1] = char.ChildRemoved:Connect(removePaper)
				conns[#conns+1] = LocalPlayer.Backpack.ChildAdded:Connect(function(obj)
					if obj.Name == "LibraryHintPaper" or obj.Name == "LibraryHintPaperHard" then
						addPaper(obj)
					end
				end)
				conns[#conns+1] = LocalPlayer.Backpack.ChildRemoved:Connect(removePaper)
			end
		end
	})
end

manageToggle("AutoCodeFire",   "Fire",AutoGroup)
manageToggle("AutoCodeNotify", "Notify",AutoGroup)

AutoGroup:AddDivider()

local AutoBreakerBoxToggle = AutoGroup:AddCheckbox("AutoBreakerBox", {
    Text = "Ëá™Âä®Êñ≠Ë∑ØÂô®",
    Default = false
})

local AutoHideV2Connection = nil

AutoGroup:AddCheckbox('AutoHideV2', {
    Text = 'Ëá™Âä®Ë∫≤Ëóè V2',
    Default = false,
    Callback = function(Value)
        if AutoHideV2Connection then
            AutoHideV2Connection:Disconnect()
            AutoHideV2Connection = nil
        end
        
        if Value then
            local EntityDistances = {
                RushMoving = 50,
                AmbushMoving = 100,
                A60 = 100,
                A120 = 35,
                GlitchRush = 50,
                GlitchAmbush = 100,
                BackdoorRush = 50
            }
            
            local function GetHiding()
                local Closest, Prompt
                local currRoom = workspace.CurrentRooms[LocalPlayer:GetAttribute('CurrentRoom')]
                if not currRoom then return nil end
                
                local char = LocalPlayer.Character
                if not char then return nil end
                
                local hrp = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Collision') or char.PrimaryPart
                if not hrp then return nil end

                local function distFromPlayer(model)
                    if not model then return math.huge end
                    local part = model.PrimaryPart or model:FindFirstChildWhichIsA('BasePart', true)
                    if not part then return math.huge end
                    return (part.Position - hrp.Position).Magnitude
                end

                local assets = currRoom:FindFirstChild('Assets')
                if assets then
                    for _, v in pairs(assets:GetChildren()) do
                        if v:IsA('Model') then
                            if (((v.Name == 'Locker_Large') or (v.Name == 'Wardrobe') or (v.Name == 'Toolshed') or 
                                 (v.Name == 'Bed') or (v.Name == 'Rooms_Locker') or (v.Name == 'Rooms_Locker_Fridge') or 
                                 (v.Name == 'Backdoor_Wardrobe')) and v:FindFirstChild('HidePrompt') and 
                                v:FindFirstChild('HiddenPlayer')) then
                                if (not v.HiddenPlayer.Value and not v:FindFirstChild('HideEntityOnSpot', true)) then
                                    if Closest then
                                        if (distFromPlayer(v) < distFromPlayer(Closest)) then
                                            Closest = v
                                            Prompt = v.HidePrompt
                                        end
                                    else
                                        Closest = v
                                        Prompt = v.HidePrompt
                                    end
                                end
                            elseif v.Name == 'Double_Bed' then
                                for _, x in pairs(v:GetChildren()) do
                                    if x.Name == 'DoubleBed' and x:FindFirstChild('HidePrompt') and x:FindFirstChild('HiddenPlayer') then
                                        if (not x.HiddenPlayer.Value and not x:FindFirstChild('HideEntityOnSpot', true)) then
                                            if Closest then
                                                if (distFromPlayer(x) < distFromPlayer(Closest)) then
                                                    Closest = x
                                                    Prompt = x.HidePrompt
                                                end
                                            else
                                                Closest = x
                                                Prompt = x.HidePrompt
                                            end
                                        end
                                    end
                                end
                            elseif v.Name == 'Dumpster' then
                                for _, x in pairs(v:GetChildren()) do
                                    if x:FindFirstChild('HidePrompt') and x:FindFirstChild('HiddenPlayer') then
                                        local dumpsterBaseHasSpot = v:FindFirstChild('DumpsterBase') and v.DumpsterBase:FindFirstChild('HideEntityOnSpot')
                                        if (not x.HiddenPlayer.Value and not dumpsterBaseHasSpot) then
                                            if Closest then
                                                if (distFromPlayer(x) < distFromPlayer(Closest)) then
                                                    Closest = x
                                                    Prompt = x.HidePrompt
                                                end
                                            else
                                                Closest = x
                                                Prompt = x.HidePrompt
                                            end
                                        end
                                    end
                                end
                            end
                        elseif v:IsA('Folder') then
                            if v.Name == 'Blockage' then
                                for _, x in pairs(v:GetChildren()) do
                                    if x:IsA('Model') and x.Name == 'Wardrobe' and x:FindFirstChild('HiddenPlayer') and x:FindFirstChild('HidePrompt') then
                                        if not x.HiddenPlayer.Value then
                                            if Closest then
                                                if (distFromPlayer(x) < distFromPlayer(Closest)) then
                                                    Closest = x
                                                    Prompt = x.HidePrompt
                                                end
                                            else
                                                Closest = x
                                                Prompt = x.HidePrompt
                                            end
                                        end
                                    end
                                end
                            elseif v.Name == 'Vents' then
                                for _, x in pairs(v:GetChildren()) do
                                    if x.Name == 'CircularVent' and x:FindFirstChild('Grate') and 
                                       x.Grate:FindFirstChild('HidePrompt') and x:FindFirstChild('HiddenPlayer') then
                                        if (not x.HiddenPlayer.Value and not v:FindFirstChild('HideEntityOnSpot', true)) then
                                            if Closest then
                                                if (distFromPlayer(x) < distFromPlayer(Closest)) then
                                                    Closest = x
                                                    Prompt = x.Grate.HidePrompt
                                                end
                                            else
                                                Closest = x
                                                Prompt = x.Grate.HidePrompt
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                for _, v in pairs(currRoom:GetChildren()) do
                    if v:IsA('Model') then
                        if v.Name == 'CircularVent' and v:FindFirstChild('Grate') and 
                           v.Grate:FindFirstChild('HidePrompt') and v:FindFirstChild('HiddenPlayer') then
                            if (not v.HiddenPlayer.Value and not v:FindFirstChild('HideEntityOnSpot', true)) then
                                if Closest then
                                    if (distFromPlayer(v) < distFromPlayer(Closest)) then
                                        Closest = v
                                        Prompt = v.Grate.HidePrompt
                                    end
                                else
                                    Closest = v
                                    Prompt = v.Grate.HidePrompt
                                end
                            end
                        end
                    end
                end

                return Prompt
            end

            AutoHideV2Connection = RunService.Heartbeat:Connect(function()
                if not Toggles.AutoHideV2.Value then 
                    AutoHideV2Connection:Disconnect()
                    AutoHideV2Connection = nil
                    return 
                end
                
                local char = LocalPlayer.Character
                if not char or not char:FindFirstChild('HumanoidRootPart') then return end
                
                for entityName, detectionDistance in pairs(EntityDistances) do
                    local entity = workspace:FindFirstChild(entityName)
                    if entity and entity.PrimaryPart then
                        local dist = (char.HumanoidRootPart.Position - entity.PrimaryPart.Position).Magnitude
                        if dist <= detectionDistance then
                            local Prompt = GetHiding()
                            if Prompt then
                                pcall(function()
                                    fireproximityprompt(Prompt)
                                end)
                            end
                        else
                            if char:GetAttribute('Hiding') then
                                char:SetAttribute('Hiding', false)
                            end
                        end
                    end
                end
            end)
        end
    end
})

AutoGroup:AddDropdown('HidingType', {
    Text = 'Ëá™Âä®Ë∫≤ËóèÊ®°Âºè',
    Default = 'ÂÆâÂÖ®ÊÖ¢ÈÄü',
    Values = {'ÂÆâÂÖ®ÊÖ¢ÈÄü', 'Âç±Èô©Âø´ÈÄü'},
    Callback = function(Value)
        _G.HidingMode = Value
    end
})

AutoGroup:AddSlider('PredictionTime', {
    Text = 'È¢ÑÊµãÊó∂Èó¥',
    Default = 1.5,
    Min = 0.1,
    Max = 1.5,
    Rounding = 2,
    Compact = true,
    Suffix = 's',
    Callback = function(Value)
        _G.PredictionTime = Value
    end
})

AutoGroup:AddSlider('DistanceMultiplier', {
    Text = 'Ë∑ùÁ¶ª‰πòÊï∞',
    Default = 1,
    Min = 1,
    Max = 1.5,
    Rounding = 1,
    Compact = true,
    Suffix = 'x',
    Callback = function(Value)
        _G.DistanceMultiplier = Value
    end
})



local AntiConnections = {}

local AntiDreadToggle = AntiEntityGroup:AddCheckbox("AntiDread", {
    Text = "Èò≤ÊÅêÊÉß(Dread)",
    Default = false,
    Callback = function(Value)
        if Value then
            Dread.Name = "FuckYouDread"
        else
            Dread.Name = "Dread"
        end
    end
})

local AntiScreechToggle = AntiEntityGroup:AddCheckbox("AntiScreech", {
    Text = "Èò≤Â∞ñÂè´(Screech)",
    Default = false,
    Callback = function(Value)
        if Value then
            Screech.Name = "FuckYouScreech"
        else
            Screech.Name = "Screech"
        end
    end
})

local AntiSnareToggle = AntiEntityGroup:AddCheckbox("AntiSnare", {
    Text = "Èò≤Èô∑Èò±(Snare)",
    Default = false,
    Callback = function(Value)
        for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
            if v.Name == "Snare" and v.Parent and v.Parent.Name ~= "Snare" then
                v:WaitForChild("Hitbox").CanTouch = not Value
            end
        end
    end
})

local AntiHaltToggle = AntiEntityGroup:AddCheckbox("AntiHalt", {
    Text = "Èò≤ÂÅúÊªû(Halt)",
    Default = false,
    Callback = function(Value)
        if Value then
            Halt.Name = "FuckYouHalt"
        else
            Halt.Name = "Shade"
        end
    end
})

local AntiSurgeToggle = AntiEntityGroup:AddCheckbox("AntiSurge", {
    Text = "Èò≤Surge",
    Default = false,
    Callback = function(Value)
        if Value then
            local surgeClient = game.ReplicatedStorage:WaitForChild('FloorReplicated'):WaitForChild('ClientRemote'):FindFirstChild('SurgeClient')
            if surgeClient then
                surgeClient:Destroy()
            end
        end
    end
})

local AntiDupeToggle = AntiEntityGroup:AddCheckbox("AntiDupe", {
    Text = "Èò≤Â§çÂà∂(Dupe)",
    Default = false,
    Callback = function(Value)
        for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
            if v.Name == "DoorFake" then
                v:WaitForChild("Hidden").CanTouch = not Value
                if v:FindFirstChild("Lock") then
                    v:FindFirstChild("Lock"):FindFirstChildOfClass("ProximityPrompt").ClickablePrompt = not Value
                end
            end
        end
    end
})

local AntiEyesToggle = AntiEntityGroup:AddCheckbox("AntiEyes", {
    Text = "Èò≤ÁúºÁùõ(Eyes)",
    Default = false
})

local AntiFigureHearToggle = FloorAntiEntityGroup:AddCheckbox("AntiFigure", {
    Text = "Èò≤È£ûÂì•Âê¨Ëßâ(Figure Hear)",
    Default = false
})

BypassGroup:AddCheckbox('InfCrucifix', {
    Text = 'Êó†ÈôêÂçÅÂ≠óÊû∂',
    Default = false,
    Risky = true,
    Callback = function(Value)
        local Replicated = game:GetService('ReplicatedStorage')
        local RemoteFolder = Replicated:FindFirstChild('EntityInfo') or Replicated:FindFirstChild('RemotesFolder') or Replicated:FindFirstChild('Bricks')

        if not RemoteFolder then
            return
        end

        local DropItem = RemoteFolder:FindFirstChild('DropItem')
        if not DropItem then
            return
        end

        local player = game.Players.LocalPlayer
        local Run = game:GetService('RunService')
        local rayparams = RaycastParams.new()

        rayparams.FilterType = Enum.RaycastFilterType.Exclude
        rayparams.FilterDescendantsInstances = {
            player.Character,
            workspace.CurrentRooms,
        }

        local distances = {
            RushMoving = 54,
            AmbushMoving = 67,
            A60 = 70,
        }
        local conn
        local lastCheck = 0

        local function findCrucifixTool()
            local c = player.Character
            if c then
                for _, child in ipairs(c:GetChildren()) do
                    if child:IsA('Tool') and child.Name:lower():find('crucifix', 1, true) then
                        return child
                    end
                end
            end

            for _, child in ipairs(player.Backpack:GetChildren()) do
                if child:IsA('Tool') and child.Name:lower():find('crucifix', 1, true) then
                    return child
                end
            end

            return nil
        end

        local function fireInteract(p)
            if not p then
                return
            end
            pcall(fireproximityprompt, p)
        end

        if not Value then
            if conn then
                conn:Disconnect()
                conn = nil
            end
            return
        end

        conn = Run.Heartbeat:Connect(function(dt)
            if not Value then
                return
            end

            lastCheck = lastCheck + dt
            if lastCheck < 0.2 then
                return
            end

            lastCheck = 0

            local char = player.Character
            local root = char and (char:FindFirstChild('CollisionPart') or char:FindFirstChild('HumanoidRootPart'))

            if not root then
                return
            end

            for _, v in ipairs(workspace:GetChildren()) do
                local d = distances[v.Name]
                if d and v.PrimaryPart then
                    local pt = root.Position
                    local dir = v.PrimaryPart.Position - pt
                    local hit = workspace:Raycast(pt, dir, rayparams)

                    if hit and hit.Instance:IsDescendantOf(v) then
                        if (pt - v.PrimaryPart.Position).Magnitude < d then
                            local tool = findCrucifixTool()
                            if tool then
                                DropItem:FireServer(tool)
                                task.defer(function()
                                    task.wait(0.54)
                                    local drops = workspace:FindFirstChild('Drops')
                                    if drops and drops:FindFirstChild('Crucifix') then
                                        local p = drops.Crucifix:FindFirstChildOfClass('ProximityPrompt')
                                        if p then
                                            fireInteract(p)
                                        end
                                    end
                                end)
                            end
                        end
                    end
                end
            end
        end)
    end
})

BypassGroup:AddCheckbox('InfItems', {
    Text = 'Êó†ÈôêÁâ©ÂìÅ',
    Default = false,
    Callback = function(Value)
        local Replicated = game:GetService('ReplicatedStorage')
        local RemoteFolder = Replicated:FindFirstChild('EntityInfo') or Replicated:FindFirstChild('RemotesFolder') or Replicated:FindFirstChild('Bricks')

        if not RemoteFolder then
            return
        end

        local DropItem = RemoteFolder:FindFirstChild('DropItem')
        if not DropItem then
            return
        end

        local player = game.Players.LocalPlayer
        local roomFolder = workspace:FindFirstChild('CurrentRooms')
        if not roomFolder then
            return
        end

        local function fireInteract(p)
            if p then
                pcall(fireproximityprompt, p)
            end
        end

        local function findToolByName(search)
            search = search:lower()
            local c = player.Character
            if c then
                for _, child in ipairs(c:GetChildren()) do
                    if child:IsA('Tool') and child.Name:lower():find(search, 1, true) then
                        return child
                    end
                end
            end

            for _, child in ipairs(player.Backpack:GetChildren()) do
                if child:IsA('Tool') and child.Name:lower():find(search, 1, true) then
                    return child
                end
            end

            return nil
        end

        local function addFake(prompt, toolName)
            if not prompt or not prompt:IsA('ProximityPrompt') or prompt:GetAttribute('HasFake') then
                return
            end

            prompt:SetAttribute('HasFake', true)
            local fakePrompt = prompt:Clone()
            fakePrompt.Name = 'FakePrompt'
            fakePrompt.Parent = prompt.Parent
            fakePrompt.Enabled = true
            fakePrompt.ClickablePrompt = true
            prompt.Enabled = false
            prompt.ClickablePrompt = false

            fakePrompt.Triggered:Connect(function()
                local toolInst = findToolByName(toolName)
                if not toolInst then
                    return
                end

                DropItem:FireServer(toolInst)

                local con
                local timedOut = false

                task.delay(1, function()
                    timedOut = true
                end)

                con = workspace.Drops.ChildAdded:Connect(function(v)
                    if timedOut then
                        con:Disconnect()
                        return
                    end

                    local newPrompt = v:FindFirstChildOfClass('ProximityPrompt')
                    if newPrompt then
                        if toolName == 'Lockpick' then
                            fireInteract(newPrompt)
                            fireInteract(prompt)
                        elseif toolName == 'Shears' then
                            fireInteract(prompt)
                            fireInteract(newPrompt)
                        else
                            fireInteract(newPrompt)
                            fireInteract(prompt)
                        end

                        task.wait(0.25)
                        con:Disconnect()
                    end
                end)
            end)
        end

        local function scanPrompts(parentsMap, namesMap)
            local found = {}
            for _, v in ipairs(roomFolder:GetDescendants()) do
                if v:IsA('ProximityPrompt') and (parentsMap[v.Parent.Name] or namesMap[v.Name]) then
                    table.insert(found, v)
                end
            end
            return found
        end

        local function cleanupEnableReal()
            for _, v in ipairs(roomFolder:GetDescendants()) do
                if v.Name == 'FakePrompt' and v.Parent then
                    v:Destroy()
                elseif v:IsA('ProximityPrompt') and v.Name ~= 'FakePrompt' then
                    pcall(function()
                        v.Enabled = true
                        v.ClickablePrompt = true
                        if v:GetAttribute('HasFake') == true then
                            v:SetAttribute('HasFake', nil)
                        end
                    end)
                end
            end
        end

        local LockpickParents = {
            ChestBoxLocked = true,
            Locker_Small_Locked = true,
            Toolbox_Locked = true,
        }

        local LockpickNames = {
            UnlockPrompt = true,
            ThingToEnable = true,
            LockPrompt = true,
            SkullPrompt = true,
            FusesPrompt = true,
        }

        local ShearsParents = {
            Chest_Vine = true,
            CuttableVines = true,
            Cellar = true,
        }

        local ShearsNames = {SkullPrompt = true}

        local KeyParents = {
            Keyhole = true,
            LockedDoor = true,
        }

        local KeyNames = {KeyPrompt = true}

        local CrowbarParents = {
            SealedCrate = true,
            Boarded = true,
        }

        local CrowbarNames = {PryPrompt = true}

        local InfStore, InfSStore, InfKStore, InfCStore = {}, {}, {}, {}
        local attachConn, roomConn, lastCheck = nil, nil, 0

        if not Value then
            cleanupEnableReal()
            InfStore, InfSStore, InfKStore, InfCStore = {}, {}, {}, {}

            if attachConn then
                attachConn:Disconnect()
                attachConn = nil
            end
            if roomConn then
                roomConn:Disconnect()
                roomConn = nil
            end
            return
        end

        local function tryAttachAll()
            local char = player.Character
            if not char then
                return
            end

            local function attachIfHas(toolName, store)
                local hasTool = char:FindFirstChild(toolName) or player.Backpack:FindFirstChild(toolName)
                if hasTool then
                    for _, prompt in ipairs(store) do
                        if prompt and prompt.Parent and not prompt:GetAttribute('HasFake') then
                            addFake(prompt, toolName)
                        end
                    end
                end
            end

            attachIfHas('Lockpick', InfStore)
            attachIfHas('Shears', InfSStore)
            attachIfHas('Key', InfKStore)
            attachIfHas('Crowbar', InfCStore)
        end

        local function rescanAll()
            InfStore = scanPrompts(LockpickParents, LockpickNames)
            InfSStore = scanPrompts(ShearsParents, ShearsNames)
            InfKStore = scanPrompts(KeyParents, KeyNames)
            InfCStore = scanPrompts(CrowbarParents, CrowbarNames)

            tryAttachAll()
        end

        rescanAll()

        roomConn = roomFolder.ChildAdded:Connect(rescanAll)
        attachConn = RunService.Heartbeat:Connect(function(dt)
            if not Value then
                return
            end

            lastCheck = lastCheck + dt
            if lastCheck < 0.2 then
                return
            end

            lastCheck = 0
            tryAttachAll()
        end)

        local function hookChildChanges(container)
            container.ChildAdded:Connect(function(child)
                local name = child.Name:lower()
                if name:find('lockpick', 1, true) or name:find('skeleton', 1, true) then
                    InfStore = scanPrompts(LockpickParents, LockpickNames)
                    tryAttachAll()
                elseif name:find('shears', 1, true) then
                    InfSStore = scanPrompts(ShearsParents, ShearsNames)
                    tryAttachAll()
                elseif name:find('key', 1, true) then
                    InfKStore = scanPrompts(KeyParents, KeyNames)
                    tryAttachAll()
                elseif name:find('crowbar', 1, true) then
                    InfCStore = scanPrompts(CrowbarParents, CrowbarNames)
                    tryAttachAll()
                end
            end)
        end

        player.CharacterAdded:Connect(function(char)
            hookChildChanges(char)
        end)
        hookChildChanges(player.Backpack)
    end
})

BypassGroup:AddDivider()

local AnticheatManipulationToggle = BypassGroup:AddCheckbox("AnticheatManipulation", {
    Text = "Âèç‰ΩúÂºäÊìçÁ∫µ",
    Default = false
})

local AntiCheatManipulationKeybind = AnticheatManipulationToggle:AddKeyPicker("AntiCheatManipulation", {
    Text = "Âèç‰ΩúÂºäÊìçÁ∫µ",
    Default = "T",
    Modes = "Always", "Toggle", "Hold",
    Mode = "Hold",
    SyncToggleState = true,
})

local AutoMode = 'Toggle'
local PreviousMode = 'Toggle'
local AutoDistance = 166
local ActiveEntities = {}

local function setGodmode(state)
    local char = LocalPlayer.Character
    if not char then return end

    local hum = char:FindFirstChildOfClass('Humanoid')
    local collision = char:FindFirstChild('Collision')

    if not (hum and collision) then return end
    
    if state then
        hum.HipHeight = 0.09
        collision.Size = Vector3.new(1, 3, 3)
        if collision:FindFirstChild('CollisionCrouch') then
            collision.CollisionCrouch.Size = Vector3.new(1, 3, 3)
        end
    else
        hum.HipHeight = 2.4
        collision.Size = Vector3.new(5.5, 3, 3)
        if collision:FindFirstChild('CollisionCrouch') then
            collision.CollisionCrouch.Size = Vector3.new(5.5, 3, 3)
        end
    end
end

local function safeDisableGod()
    if not LocalPlayer.Character then return end

    local hum = LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
    local collision = LocalPlayer.Character:FindFirstChild('Collision')

    if not (hum and collision) then
        setGodmode(false)
        return
    end

    local wasNoclip = Toggles.Noclip and Toggles.Noclip.Value
    local shouldShim = (AutoMode ~= 'Never') and not wasNoclip

    if (shouldShim and Toggles.Noclip) then
        Toggles.Noclip:SetValue(true)
    end

    setGodmode(false)

    if (shouldShim and Toggles.Noclip) then
        task.delay(0.2, function()
            if (Toggles.Noclip and Toggles.Noclip.Value) then
                Toggles.Noclip:SetValue(false)
            end
        end)
    end
end

BypassGroup:AddDropdown('GodmodeMode', {
    Text = '‰∏äÂ∏ùÊ®°ÂºèÊ®°Âºè',
    Default = 'Toggle',
    Values = {
        'Toggle',
        'Automatic',
        'Hold',
        'Always',
        'Never'
    },
    Callback = function(mode)
        if ((PreviousMode == 'Always') and (mode ~= 'Always')) then
            if (Toggles.PositionSpoof and Toggles.PositionSpoof.Value) then
                Toggles.PositionSpoof:SetValue(false)
                setGodmode(false)

                if (Toggles.Noclip and not Toggles.Noclip.Value) then
                    Toggles.Noclip:SetValue(true)
                    task.delay(0.2, function()
                        if (Toggles.Noclip and Toggles.Noclip.Value) then
                            Toggles.Noclip:SetValue(false)
                        end
                    end)
                end
            end
        end

        AutoMode = mode
        PreviousMode = mode

        if Options.PositionSpoofKey then
            Options.PositionSpoofKey.Text = '‰∏äÂ∏ùÊ®°Âºè (' .. mode .. ')'
        end
        if (mode == 'Always') then
            Toggles.PositionSpoof:SetValue(true)
        elseif (mode == 'Never') then
            Toggles.PositionSpoof:SetValue(false)
        end
    end,
})

local GodmodeToggle = BypassGroup:AddCheckbox('PositionSpoof', {
    Text = '‰∏äÂ∏ùÊ®°ÂºèÂºÄÂÖ≥',
    Default = false,
    Callback = function(v)
        if v then
            setGodmode(true)
        else
            safeDisableGod()
        end
    end,
})

local GodmodeKeybind = GodmodeToggle:AddKeyPicker('PositionSpoofKey', {
    Default = 'K',
    Mode = 'Toggle',
    Text = '‰∏äÂ∏ùÊ®°Âºè',
    NoUI = false,
    SyncToggleState = true,
})

local EntList = {
    'a60',
    'ambushmoving',
    'backdoorrush',
    'rushmoving',
    'mandrake',
    'a120',
    'glitchrush',
    'glitchambush',
    'figure',
    'eyes'
}

local function IsValidEntity(entity)
    return table.find(EntList, entity.Name:lower()) ~= nil
end

workspace.DescendantAdded:Connect(function(entity)
    if not IsValidEntity(entity) then
        return
    end

    local part = entity:FindFirstChildWhichIsA('BasePart')
    if part then
        ActiveEntities[entity] = part
    end
end)

RunService.RenderStepped:Connect(function()
    local lib = getgenv().Library
    if (not lib or lib.Unloaded) then
        return
    end

    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
    if not root then
        return
    end
    
    if (AutoMode == 'Never') then
        if Toggles.PositionSpoof and Toggles.PositionSpoof.Value then
            Toggles.PositionSpoof:SetValue(false)
        end
    elseif (AutoMode == 'Always') then
        if not Toggles.PositionSpoof.Value then
            Toggles.PositionSpoof:SetValue(true)
        end
    elseif (AutoMode == 'Automatic') then
        local shouldEnable = false

        for entity, part in pairs(ActiveEntities) do
            if (entity.Parent == nil) then
                ActiveEntities[entity] = nil
            elseif part then
                local dist = (root.Position - part.Position).Magnitude
                if (dist < AutoDistance) then
                    shouldEnable = true
                    break
                end
            end
        end

        if shouldEnable then
            if not Toggles.PositionSpoof.Value then
                Toggles.PositionSpoof:SetValue(true)
            end
        elseif Toggles.PositionSpoof.Value then
            Toggles.PositionSpoof:SetValue(false)
            safeDisableGod()
        end
    elseif (AutoMode == 'Hold') then
        local keyCode = Options.PositionSpoofKey and Options.PositionSpoofKey.Value
        if (keyCode and UserInputService:IsKeyDown(keyCode)) then
            if not Toggles.PositionSpoof.Value then
                Toggles.PositionSpoof:SetValue(true)
            end
        elseif Toggles.PositionSpoof.Value then
            Toggles.PositionSpoof:SetValue(false)
            safeDisableGod()
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(0.1)
        if (Toggles.PositionSpoof and Toggles.PositionSpoof.Value) then
            setGodmode(true)
        end
    end
end)

BypassGroup:AddSlider('AutoDistance', {
    Text = 'Ëá™Âä®Ê£ÄÊµãË∑ùÁ¶ª',
    Default = 166,
    Min = 50,
    Max = 300,
    Rounding = 0,
    Compact = true,
    Callback = function(Value)
        AutoDistance = Value
    end
})

LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(1.5)
    if Toggles.PositionSpoof and Toggles.PositionSpoof.Value then
        setGodmode(true)
    end
end)



BypassGroup:AddDivider()
BypassGroup:AddLabel('<font color="rgb(255,255,0)">‰∏äÂ∏ùÊ®°ÂºèËØ¥Êòé:</font>')
BypassGroup:AddLabel('- ÂàáÊç¢Ê®°Âºè: ÊâãÂä®ÂºÄÂÖ≥')
BypassGroup:AddLabel('- Ëá™Âä®Ê®°Âºè: Ê£ÄÊµãÂà∞ÂÆû‰ΩìËá™Âä®ÂºÄÂêØ')
BypassGroup:AddLabel('- ‰øùÊåÅÊ®°Âºè: Êåâ‰ΩèÂø´Êç∑ÈîÆÂºÄÂêØ')
BypassGroup:AddLabel('- ÂßãÁªàÂºÄÂêØ: ‰∏ÄÁõ¥‰øùÊåÅ‰∏äÂ∏ùÊ®°Âºè')
BypassGroup:AddLabel('- ‰ªé‰∏çÂºÄÂêØ: Á¶ÅÁî®‰∏äÂ∏ùÊ®°Âºè')
local ESPTranslations = {
    Door = "Èó®",
    Key = "Èí•Âåô",
    Closet = "ÊüúÂ≠ê",
    Locker = "ÂÇ®Áâ©Êüú", 
    Bed = "Â∫ä",
    Vent = "ÈÄöÈ£éÂè£",
    Fridge = "ÂÜ∞ÁÆ±",
    ["Double Bed"] = "Âèå‰∫∫Â∫ä",
    ["Dump Ster"] = "ÂûÉÂúæÊ°∂",
    Lever = "ÊãâÊùÜ",
    ["Gate Lever"] = "Â§ßÈó®ÊãâÊùÜ",
    ["Timer Lever"] = "ËÆ°Êó∂ÊãâÊùÜ",
    Book = "‰π¶Á±ç",
    Breaker = "Êñ≠Ë∑ØÂô®",
    Generator = "ÂèëÁîµÊú∫",
    Fuse = "‰øùÈô©‰∏ù",
    Anchor = "ÈîöÁÇπ",
    ["Water Pump"] = "Ê∞¥Ê≥µ",
    Ladder = "Ê¢ØÂ≠ê",
    Flashlight = "ÊâãÁîµÁ≠í",
    Lockpick = "ÂºÄÈîÅÂ∑•ÂÖ∑",
    Vitamin = "Áª¥ÁîüÁ¥†",
    Bandage = "Áª∑Â∏¶",
    ["Star Vial"] = "Êòü‰πãÁì∂",
    ["Star Bottle"] = "Êòü‰πãÁì∂",
    ["Star Jug"] = "Êòü‰πãÂ£∂",
    ["Shake Light"] = "ÊëáÊëÜÊâãÁîµ",
    ["Strap Light"] = "ÁªëÂ∏¶ÁÅØ",
    ["Bulk Light"] = "Â§ßÁÅØ",
    Battery = "ÁîµÊ±†",
    Candle = "Ëú°ÁÉõ",
    Crucifix = "ÂçÅÂ≠óÊû∂",
    ["Glow Stick"] = "ËçßÂÖâÊ£í",
    ["Skeleton Key"] = "È™∑È´ÖÈí•Âåô",
    Candy = "Á≥ñÊûú",
    ["Mini Shield"] = "Â∞èÊä§Áõæ",
    ["Big Shield"] = "Â§ßÊä§Áõæ",
    ["Bandage Pack"] = "Áª∑Â∏¶ÂåÖ",
    ["Flashlight BatteryPack"] = "ÊâãÁîµÁîµÊ±†ÂåÖ",
    ["Moonlight Candle"] = "ÊúàÂÖâËú°ÁÉõ",
    ["Laser Pointer"] = "ÊøÄÂÖâÁ¨î",
    ["Holy Grenade"] = "Á•ûÂú£ÊâãÈõ∑",
    Shears = "Ââ™ÂàÄ",
    Smoothie = "ÂÜ∞Ê≤ô",
    Cheese = "Â•∂ÈÖ™",
    Bread = "Èù¢ÂåÖ",
    ["Alarm Clock"] = "ÈóπÈíü",
    ["Moonlight Smoothie"] = "ÊúàÂÖâÂÜ∞Ê≤ô",
    ["Gween Soda"] = "Ê†ºÊûóÊ±ΩÊ∞¥",
    ["Glitch Cube"] = "ÊïÖÈöúÊñπÂùó",
    ["Rift Jar"] = "Ë£ÇÈöôÁΩê",
    Compass = "ÊåáÂçóÈíà",
    Lantern = "ÁÅØÁ¨º",
    ["Multi Tool"] = "Â§öÂäüËÉΩÂ∑•ÂÖ∑",
    Lotus = "Ëé≤Ëä±",
    ["Jeff Tip"] = "Êù∞Â§´Â∞èË¥π",
    ["Lotus Petal"] = "Ëé≤Ëä±Ëä±Áì£",
    ["Iron Key"] = "ÈìÅÈí•Âåô",
    Donut = "ÁîúÁîúÂúà",
    ["Shears Toolshed"] = "Ââ™ÂàÄÂ∑•ÂÖ∑Ê£ö",
    ["Chest Vine"] = "ÂÆùÁÆ±Ëó§Ëîì",
    ["[Locked] Chest"] = "[‰∏äÈîÅ]ÂÆùÁÆ±",
    Chest = "ÂÆùÁÆ±",
    ["Star Dust"] = "ÊòüÂ∞ò",
    Gold = "ÈáëÂ∏Å"
}

local EntityTable = {
    RushMoving = "Rush",
    AmbushMoving = "Ambush",
    A60 = "A-60", 
    A120 = "A-120",
    Eyes = "Eyes",
    GlitchRush = "GlitchRush",
    GlitchAmbush = "GlitchAmbush",
    MonumentEntity = "Monument",
    BackdoorRush = "Blitz",
    BackdoorLookman = "Lookman",
    Groundskeeper = "Groundskeeper",
    GrumbleRig = "Grumble",
    Screech = "Screech",
    Halt = "Halt",
    FigureRig = "Figure",
    Snare = "Snare",
    WorldLotus = "WorldLotus",
    Bramble = "Bramble",
    Caws = "Caws",
    Eyestalk = "Eyestalk",
    Grampy = "Grampy",
    Mandrake = "Mandrake",
    Surge = "Surge",
    Dread = "Dread",
    GloomPile = "GloomPile",
    Giggle = "Giggle"
}

local EntityESP = {
    Rush = "Rush",
    Ambush = "Ambush", 
    A60 = "A-60",
    A120 = "A-120",
    Eyes = "Eyes",
    Figure = "Figure",
    Bramble = "Bramble",
    Lookman = "Lookman",
    Blitz = "Blitz",
    Monument = "Monument",
    GlitchRush = "GlitchRush", 
    GlitchAmbush = "GlitchAmbush",
    Groundskeeper = "Groundskeeper",
    Giggle = "Giggle",
    Grumble = "Grumble"
}

function GetTranslatedText(itemType, originalName)
    return ESPTranslations[itemType] or ESPTranslations[originalName] or originalName
end

local ESPColors = {
    Players = Color3.new(1, 1, 1),
    Door = Color3.new(0, 1, 0),
    Key = Color3.new(1, 1, 0),
    Wardrobe = Color3.new(0, 0, 1),
    Entity = Color3.new(1, 0, 0),
    Items = Color3.new(1, 0, 1),
    Chest = Color3.new(1, 0.5, 0),
    Gold = Color3.new(1, 0.84, 0),
    Books = Color3.new(0, 1, 1)
}

local ESPObjects = {
    Players = {},
    Doors = {},
    Keys = {},
    Wardrobes = {},
    Entities = {},
    Items = {},
    Chests = {},
    Gold = {},
    Books = {}
}

local ESPSettings = {
    Type = "Highlight",
    Rainbow = false,
    ShowText = true,
    ShowHighlight = true,
    Transparency = 0.75,
    FillTransparency = 0.75,
    OutlineTransparency = 0,
    ShowDistance = true,
    TextSize = 22,
    ShowLines = false,
    LinePosition = "Bottom",
    ShowArrows = false,
    ArrowOffset = 300
}

ESPLibrary.GlobalConfig = {
    IgnoreCharacter = false,
    Rainbow = false,
    Billboards = true,
    Distance = true,
    Highlighters = true,
    Tracers = false,
    Arrows = false,
    Font = Enum.Font.RobotoCondensed
}

local GoldESPTable = {}


ESPSubTab:AddCheckbox('ESPPlayers', {
     Text = "Áé©ÂÆ∂",
     Default = false,
     Callback = function(Value)
         if Value then
             for _, plr in ipairs(Players:GetPlayers()) do
                 if plr ~= LocalPlayer and plr.Character then
                     AddESP(plr.character, plr.Name, PlayersColor)
                 end
             end
         else
             for _, plr in ipairs(Players:GetPlayers()) do
                 if plr ~= LocalPlayer and plr.Character then
                     ESPLibrary:RemoveESP(plr.Character)
                 end
             end
         end
     end
}):AddColorPicker('ESPPlayersColor', {
    Default = ESPColors.Players,
    Title = 'Áé©ÂÆ∂È¢úËâ≤',
    Callback = function(Value)
        ESPColors.Players = Value
        ESPManager:UpdatePlayersColor()
    end
})

ESPSubTab:AddCheckbox('ESPDoor', {
    Text = "Èó®",
    Default = false,
    Callback = function(Value)
        if Value then
            ESPManager:EnableDoorsESP()
        else
            ESPManager:DisableDoorsESP()
        end
    end
}):AddColorPicker('ESPDoorColor', {
    Default = ESPColors.Door,
    Title = 'Èó®È¢úËâ≤',
    Callback = function(Value)
        ESPColors.Door = Value
        ESPManager:UpdateDoorsColor()
    end
})

ESPSubTab:AddCheckbox('ESPKey', {
    Text = "Èí•Âåô",
    Default = false,
    Callback = function(Value)
        if Value then
            ESPManager:EnableKeysESP()
        else
            ESPManager:DisableKeysESP()
        end
    end
}):AddColorPicker('ESPKeyColor', {
    Default = ESPColors.Key,
    Title = 'Èí•ÂåôÈ¢úËâ≤',
    Callback = function(Value)
        ESPColors.Key = Value
        ESPManager:UpdateKeysColor()
    end
})

ESPSubTab:AddCheckbox('ESPWardrobe', {
    Text = "Ë°£Êüú",
    Default = false,
    Callback = function(Value)
        if Value then
            ESPManager:EnableWardrobesESP()
        else
            ESPManager:DisableWardrobesESP()
        end
    end
}):AddColorPicker('ESPWardrobeColor', {
    Default = ESPColors.Wardrobe,
    Title = 'Ë°£ÊüúÈ¢úËâ≤',
    Callback = function(Value)
        ESPColors.Wardrobe = Value
        ESPManager:UpdateWardrobesColor()
    end
})

ESPSubTab:AddCheckbox('ESPEntity', {
    Text = "ÂÆû‰Ωì",
    Default = false,
    Callback = function(Value)
        if Value then
            ESPManager:EnableEntitiesESP()
        else
            ESPManager:DisableEntitiesESP()
        end
    end
}):AddColorPicker('ESPEntityColor', {
    Default = ESPColors.Entity,
    Title = 'ÂÆû‰ΩìÈ¢úËâ≤',
    Callback = function(Value)
        ESPColors.Entity = Value
        ESPManager:UpdateEntitiesColor()
    end
})

ESPSubTab:AddCheckbox('ESPItems', {
    Text = "Áâ©ÂìÅ",
    Default = false,
    Callback = function(Value)
        if Value then
            ESPManager:EnableItemsESP()
        else
            ESPManager:DisableItemsESP()
        end
    end
}):AddColorPicker('ESPItemsColor', {
    Default = ESPColors.Items,
    Title = 'Áâ©ÂìÅÈ¢úËâ≤',
    Callback = function(Value)
        ESPColors.Items = Value
        ESPManager:UpdateItemsColor()
    end
})

ESPSubTab:AddCheckbox('ESPChest', {
    Text = "ÁÆ±Â≠ê",
    Default = false,
    Callback = function(Value)
        if Value then
            ESPManager:EnableChestsESP()
        else
            ESPManager:DisableChestsESP()
        end
    end
}):AddColorPicker('ESPChestColor', {
    Default = ESPColors.Chest,
    Title = 'ÁÆ±Â≠êÈ¢úËâ≤',
    Callback = function(Value)
        ESPColors.Chest = Value
        ESPManager:UpdateChestsColor()
    end
})

ESPSubTab:AddCheckbox('ESPGold', {
    Text = "ÈáëÂ∏Å",
    Default = false,
    Callback = function(Value)
        if Value then
            ESPManager:EnableGoldESP()
        else
            ESPManager:DisableGoldESP()
        end
    end
}):AddColorPicker('ESPGoldColor', {
    Default = ESPColors.Gold,
    Title = 'ÈáëÂ∏ÅÈ¢úËâ≤',
    Callback = function(Value)
        ESPColors.Gold = Value
        ESPManager:UpdateGoldColor()
    end
})

ESPSubTab:AddCheckbox('ESPBooks', {
    Text = "‰π¶",
    Default = false,
    Callback = function(Value)
        if Value then
            ESPManager:EnableBooksESP()
        else
            ESPManager:DisableBooksESP()
        end
    end
}):AddColorPicker('ESPBooksColor', {
    Default = ESPColors.Books,
    Title = '‰π¶È¢úËâ≤',
    Callback = function(Value)
        ESPColors.Books = Value
        ESPManager:UpdateBooksColor()
    end
})

SettingsSubTab:AddDropdown('ESPType', {
    Values = {"Highlight", "SelectionBox", "CylinderAdornment", "SphereAdornment", "Adornment", "Text"},
    Default = 1,
    Text = "ESPÁ±ªÂûã",
    Callback = function(Value)
        ESPSettings.Type = Value
        ESPLibrary.GlobalConfig.Rainbow = ESPSettings.Rainbow
        ESPManager:RecreateAllESP()
    end
})

SettingsSubTab:AddDivider()

SettingsSubTab:AddCheckbox('ESPRainbow', {
    Text = "ÂΩ©ËôπESP",
    Default = false,
    Callback = function(Value)
        ESPSettings.Rainbow = Value
        ESPLibrary.GlobalConfig.Rainbow = Value
    end
})

SettingsSubTab:AddDivider()

SettingsSubTab:AddCheckbox('ESPShowText', {
    Text = "ÂêØÁî®ÊñáÊú¨",
    Default = true,
    Callback = function(Value)
        ESPSettings.ShowText = Value
        ESPLibrary.GlobalConfig.Billboards = Value
    end
})

SettingsSubTab:AddCheckbox('ESPShowHighlight', {
    Text = "ÂêØÁî®È´ò‰∫ÆÊòæÁ§∫",
    Default = true,
    Callback = function(Value)
        ESPSettings.ShowHighlight = Value
        ESPLibrary.GlobalConfig.Highlighters = Value
    end
})

SettingsSubTab:AddSlider('ESPTransparency', {
    Text = "ÈÄèÊòéÂ∫¶",
    Default = 0.75,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ESPSettings.Transparency = Value
        ESPManager:UpdateAllTransparency()
    end
})

SettingsSubTab:AddSlider('ESPFillTransparency', {
    Text = "Â°´ÂÖÖÈÄèÊòéÂ∫¶",
    Default = 0.75,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ESPSettings.FillTransparency = Value
        ESPManager:UpdateAllFillTransparency()
    end
})

SettingsSubTab:AddSlider('ESPOutlineTransparency', {
    Text = "ËΩÆÂªìÈÄèÊòéÂ∫¶",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ESPSettings.OutlineTransparency = Value
        ESPManager:UpdateAllOutlineTransparency()
    end
})

SettingsSubTab:AddDivider()

SettingsSubTab:AddCheckbox('ESPShowDistance', {
    Text = "ÊòæÁ§∫Ë∑ùÁ¶ª",
    Default = true,
    Callback = function(Value)
        ESPSettings.ShowDistance = Value
        ESPLibrary.GlobalConfig.Distance = Value
    end
})

SettingsSubTab:AddSlider('ESPTextSize', {
    Text = "ÊñáÊú¨Â§ßÂ∞è",
    Default = 22,
    Min = 0,
    Max = 26,
    Rounding = 0,
    Callback = function(Value)
        ESPSettings.TextSize = Value
        ESPManager:UpdateAllTextSize()
    end
})

SettingsSubTab:AddDivider()

SettingsSubTab:AddCheckbox('ESPShowLines', {
    Text = "ÂêØÁî®Á∫øÊù°(Erorr)",
    Default = false,
    Callback = function(Value)
        ESPSettings.ShowLines = Value
        ESPLibrary.GlobalConfig.Tracers = Value
        if Toggles.ESPPlayers and Toggles.ESPPlayers.Value then
            ESPManager:DisablePlayersESP()
            task.wait(0.1)
            ESPManager:EnablePlayersESP()
        end
    end
})

SettingsSubTab:AddDropdown('ESPLinePosition', {
    Values = {"Bottom", "Center", "Top", "Mouse"},
    Default = 1,
    Text = "Á∫øÊù°‰ΩçÁΩÆ",
    Callback = function(Value)
        ESPSettings.LinePosition = Value
        ESPManager:UpdateAllLinePosition()
    end
})

SettingsSubTab:AddDivider()

SettingsSubTab:AddCheckbox('ESPShowArrows', {
    Text = "ÂêØÁî®ÁÆ≠Â§¥(Erorr)",
    Default = false,
    Callback = function(Value)
        ESPSettings.ShowArrows = Value
        ESPLibrary.GlobalConfig.Arrows = Value
        if Toggles.ESPPlayers and Toggles.ESPPlayers.Value then
            ESPManager:DisablePlayersESP()
            task.wait(0.1)
            ESPManager:EnablePlayersESP()
        end
    end
})

SettingsSubTab:AddSlider('ESPArrowOffset', {
    Text = "ÁÆ≠Â§¥‰∏≠ÂøÉÂÅèÁßª(Erorr)",
    Default = 300,
    Min = 0,
    Max = 500,
    Rounding = 0,
    Callback = function(Value)
        ESPSettings.ArrowOffset = Value
        ESPManager:UpdateAllArrowOffset()
    end
})

local BrightnessSlider = ESPMiscGroup:AddSlider("Brightness", {
    Text = "‰∫ÆÂ∫¶",
    Default = 0,
    Min = 0,
    Max = 3,
    Rounding = 0,
    Callback = function(Value)
        Lighting.Brightness = Value
    end
})
local AntiLagButton = ESPMiscGroup:AddButton('AntiLag',{
    Text = "Èò≤Âç°",
    Default = false,
    Callback = function(Value)
        if Value then
            for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.Material = Enum.Material.Plastic
                end
                if v.Name == "LightFixture" or v.Name == "Carpet" or v.Name == "CarpetLight" then
                    v:Destroy()
                end
            end
        end
    end
})

ESPMiscGroup:AddCheckbox('NoFog', {
    Text = 'Êó†Èõæ',
    Default = false,
    Callback = function(Value)
        local lighting = game:GetService('Lighting')
        local cave = lighting:FindFirstChild('CaveAtmosphere')
        if Value then
            if (cave and cave:IsA('Atmosphere')) then
                cave.Density = 0
            else
                lighting.FogStart = 1000000
                lighting.FogEnd = 1000000
            end
        elseif (cave and cave:IsA('Atmosphere')) then
            cave.Density = 0.15
        else
            lighting.FogStart = 150
            lighting.FogEnd = 150
        end
    end,
})

ESPManager = {}

function ESPManager:CreateESPObject(model, name, color, extraSettings)
    local settings = {
        Name = name,
        Model = model,
        Color = color,
        MaxDistance = 5000,
        TextSize = ESPSettings.TextSize,
        ESPType = ESPSettings.Type,
        Transparency = ESPSettings.Transparency,
        StudsOffset = Vector3.new(0, 2, 0)
    }
    
    if ESPSettings.Type == "Highlight" then
        settings.FillColor = color
        settings.OutlineColor = color
        settings.FillTransparency = ESPSettings.FillTransparency
        settings.OutlineTransparency = ESPSettings.OutlineTransparency
    elseif ESPSettings.Type == "SelectionBox" then
        settings.SurfaceColor = color
        settings.Thickness = 0.1
    elseif ESPSettings.Type == "CylinderAdornment" then
        settings.Thickness = 0.1
    elseif ESPSettings.Type == "SphereAdornment" then
        settings.Thickness = 0.1
    elseif ESPSettings.Type == "Adornment" then
        settings.Thickness = 0.1
    end
    
    if extraSettings then
        for k, v in pairs(extraSettings) do
            settings[k] = v
        end
    end
    
    local success, esp = pcall(function()
        return ESPLibrary:Add(settings)
    end)
    
    if success and esp then
        return esp
    else
        warn("ÂàõÂª∫ESPÂ§±Ë¥•: ", name)
        return nil
    end
end

function ESPManager:EnablePlayersESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            self:AddPlayerESP(player)
        end
    end
    
    if not self.PlayersConnection then
        self.PlayersConnection = Players.PlayerAdded:Connect(function(player)
            if Toggles.ESPPlayers and Toggles.ESPPlayers.Value then
                player.CharacterAdded:Connect(function(character)
                    task.wait(1)
                    self:AddPlayerESP(player)
                end)
            end
        end)
    end
end

function ESPManager:DisablePlayersESP()
    for player, esp in pairs(ESPObjects.Players) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Players = {}
    
    if self.PlayersConnection then
        self.PlayersConnection:Disconnect()
        self.PlayersConnection = nil
    end
end

function ESPManager:AddPlayerESP(player)
    if ESPObjects.Players[player] then return end
    
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then 
        task.wait(1)
        character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            return
        end
    end
    
    local extraSettings = {}
    
    if ESPSettings.ShowLines then
        extraSettings.Tracer = {
            Enabled = true,
            Color = ESPColors.Players,
            From = ESPSettings.LinePosition,
            Thickness = 2,
            Transparency = 0
        }
    end
    
    if ESPSettings.ShowArrows then
        extraSettings.Arrow = {
            Enabled = true,
            Color = ESPColors.Players,
            CenterOffset = ESPSettings.ArrowOffset
        }
    end
    
    local esp = self:CreateESPObject(character, player.Name, ESPColors.Players, extraSettings)
    if esp then
        ESPObjects.Players[player] = esp
    end
end

function ESPManager:EnableDoorsESP()
    for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
        if room:FindFirstChild("Door") then
            local door = room.Door.Door
            if door and not door:GetAttribute("Used") then
                self:AddDoorESP(door, room:GetAttribute("RoomID") or room.Name)
            end
        end
    end
end

function ESPManager:DisableDoorsESP()
    for door, esp in pairs(ESPObjects.Doors) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Doors = {}
end

function ESPManager:AddDoorESP(door, roomId)
    if ESPObjects.Doors[door] then return end
    
    local isLocked = door.Parent:FindFirstChild("Lock") ~= nil
    local espText = (isLocked and "[Locked] " or "") .. "Door " .. roomId
    
    local esp = self:CreateESPObject(door, espText, ESPColors.Door)
    if esp then
        ESPObjects.Doors[door] = esp
    end
end

function ESPManager:EnableKeysESP()
    for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
        local key = room:FindFirstChild("KeyObtain", true)
        if key and not key:GetAttribute("Used") then
            self:AddKeyESP(key)
        end
    end
end

function ESPManager:DisableKeysESP()
    for key, esp in pairs(ESPObjects.Keys) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Keys = {}
end

function ESPManager:AddKeyESP(key)
    if ESPObjects.Keys[key] then return end
    
    local esp = self:CreateESPObject(key, "Key", ESPColors.Key)
    if esp then
        ESPObjects.Keys[key] = esp
    end
end

function ESPManager:EnableWardrobesESP()
    local hidingSpots = {
        Wardrobe = "Closet",
        Rooms_Locker = "Locker",
        Backdoor_Wardrobe = "Closet",
        Toolshed = "Closet",
        Locker_Large = "Locker",
        Bed = "Bed",
        Double_Bed = "Double Bed"
    }
    
    for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
        local assets = room:FindFirstChild("Assets")
        if assets then
            for _, obj in ipairs(assets:GetChildren()) do
                local spotName = hidingSpots[obj.Name]
                if spotName and obj.PrimaryPart then
                    self:AddWardrobeESP(obj, spotName)
                end
            end
        end
    end
end

function ESPManager:DisableWardrobesESP()
    for wardrobe, esp in pairs(ESPObjects.Wardrobes) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Wardrobes = {}
end

function ESPManager:AddWardrobeESP(wardrobe, name)
    if ESPObjects.Wardrobes[wardrobe] then return end
    
    local esp = self:CreateESPObject(wardrobe, name, ESPColors.Wardrobe)
    if esp then
        ESPObjects.Wardrobes[wardrobe] = esp
    end
end

function ESPManager:EnableEntitiesESP()
    local entities = {
        "RushMoving", "AmbushMoving", "A60", "A120", "Eyes", 
        "FigureRig", "GlitchRush", "GlitchAmbush", "MonumentEntity",
        "BackdoorRush", "BackdoorLookman", "Groundskeeper", "GrumbleRig",
        "Screech", "Halt", "Snare", "WorldLotus", "Bramble", "Caws",
        "Eyestalk", "Grampy", "Mandrake", "Surge", "Dread", "GloomPile", "Giggle"
    }
    
    for _, entityName in ipairs(entities) do
        local entity = workspace:FindFirstChild(entityName)
        if entity then
            self:AddEntityESP(entity, entityName)
        end
    end
    
    if not self.EntityConnections then
        self.EntityConnections = {}
    end
    
    self.EntityConnections.entityAdded = workspace.ChildAdded:Connect(function(child)
        for _, entityName in ipairs(entities) do
            if child.Name == entityName then
                task.wait(0.1)
                self:AddEntityESP(child, entityName)
            end
        end
    end)
end

function ESPManager:DisableEntitiesESP()
    for entity, esp in pairs(ESPObjects.Entities) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Entities = {}
end

function ESPManager:AddEntityESP(entity, entityType)
    if ESPObjects.Entities[entity] then return end
    local displayName = EntityTable[entityType] or entityType
    
    local espColor = ESPColors.Entity
    
    local esp = self:CreateESPObject(entity, displayName, espColor)
    if esp then
        ESPObjects.Entities[entity] = esp
        
        if not self.EntityConnections then
            self.EntityConnections = {}
        end
        
        self.EntityConnections[entity] = entity.AncestryChanged:Connect(function()
            if not entity.Parent then
                self:RemoveEntityESP(entity)
            end
        end)
    end
end

function ESPManager:DisableEntitiesESP()
    for entity, esp in pairs(ESPObjects.Entities) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Entities = {}
    
    if self.EntityConnections then
        for _, conn in pairs(self.EntityConnections) do
            pcall(function()
                conn:Disconnect()
            end)
        end
        self.EntityConnections = {}
    end
end

function ESPManager:RemoveEntityESP(entity)
    if ESPObjects.Entities[entity] then
        pcall(function()
            ESPObjects.Entities[entity]:Destroy()
        end)
        ESPObjects.Entities[entity] = nil
    end
    
    if self.EntityConnections and self.EntityConnections[entity] then
        self.EntityConnections[entity]:Disconnect()
        self.EntityConnections[entity] = nil
    end
end

function ESPManager:EnableItemsESP()
    local items = {
        Flashlight = "Flashlight",
        Lockpick = "Lockpick",
        SkeletonKey = "Skeleton Key",
        Crucifix = "Crucifix",
        Shears = "Shears",
        Vitamins = "Vitamins",
        Bandage = "Bandage"
    }
    
    for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
        for itemName, displayName in pairs(items) do
            local item = room:FindFirstChild(itemName, true)
            if item and item.PrimaryPart then
                self:AddItemESP(item, displayName)
            end
        end
    end
end

function ESPManager:DisableItemsESP()
    for item, esp in pairs(ESPObjects.Items) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Items = {}
end

function ESPManager:AddItemESP(item, name)
    if ESPObjects.Items[item] then return end
    
    local esp = self:CreateESPObject(item, name, ESPColors.Items)
    if esp then
        ESPObjects.Items[item] = esp
    end
end

function ESPManager:EnableChestsESP()
    for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
        local chest = room:FindFirstChild("ChestBox", true) or room:FindFirstChild("ChestBoxLocked", true)
        if chest and chest.PrimaryPart then
            local name = chest.Name == "ChestBoxLocked" and "Locked Chest" or "Chest"
            self:AddChestESP(chest, name)
        end
    end
end

function ESPManager:DisableChestsESP()
    for chest, esp in pairs(ESPObjects.Chests) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Chests = {}
end

function ESPManager:AddChestESP(chest, name)
    if ESPObjects.Chests[chest] then return end
    
    local esp = self:CreateESPObject(chest, name, ESPColors.Chest)
    if esp then
        ESPObjects.Chests[chest] = esp
    end
end

function ESPManager:EnableGoldESP()
    for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
        local gold = room:FindFirstChild("GoldPile", true)
        if gold and gold.PrimaryPart then
            local goldValue = gold:GetAttribute("GoldValue") or 0
            self:AddGoldESP(gold, "Gold " .. goldValue)
        end
    end
end

function ESPManager:DisableGoldESP()
    for gold, esp in pairs(ESPObjects.Gold) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Gold = {}
end

function ESPManager:AddGoldESP(gold, name)
    if ESPObjects.Gold[gold] then return end
    
    local esp = self:CreateESPObject(gold, name, ESPColors.Gold)
    if esp then
        ESPObjects.Gold[gold] = esp
    end
end

function ESPManager:EnableBooksESP()
    for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
        local book = room:FindFirstChild("LiveHintBook", true)
        if book and book.PrimaryPart then
            self:AddBookESP(book, "Book")
        end
    end
end

function ESPManager:DisableBooksESP()
    for book, esp in pairs(ESPObjects.Books) do
        if esp then
            pcall(function()
                esp:Destroy()
            end)
        end
    end
    ESPObjects.Books = {}
end

function ESPManager:AddBookESP(book, name)
    if ESPObjects.Books[book] then return end
    
    local esp = self:CreateESPObject(book, name, ESPColors.Books)
    if esp then
        ESPObjects.Books[book] = esp
    end
end

function ESPManager:UpdatePlayersColor()
    for player, esp in pairs(ESPObjects.Players) do
        if esp and esp.CurrentSettings then
            esp.CurrentSettings.Color = ESPColors.Players
            if ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillColor = ESPColors.Players
                esp.CurrentSettings.OutlineColor = ESPColors.Players
            end
            if esp.CurrentSettings.Tracer then
                esp.CurrentSettings.Tracer.Color = ESPColors.Players
            end
            if esp.CurrentSettings.Arrow then
                esp.CurrentSettings.Arrow.Color = ESPColors.Players
            end
        end
    end
end

function ESPManager:UpdateDoorsColor()
    for door, esp in pairs(ESPObjects.Doors) do
        if esp and esp.CurrentSettings then
            esp.CurrentSettings.Color = ESPColors.Door
            if ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillColor = ESPColors.Door
                esp.CurrentSettings.OutlineColor = ESPColors.Door
            end
        end
    end
end

function ESPManager:UpdateKeysColor()
    for key, esp in pairs(ESPObjects.Keys) do
        if esp and esp.CurrentSettings then
            esp.CurrentSettings.Color = ESPColors.Key
            if ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillColor = ESPColors.Key
                esp.CurrentSettings.OutlineColor = ESPColors.Key
            end
        end
    end
end

function ESPManager:UpdateWardrobesColor()
    for wardrobe, esp in pairs(ESPObjects.Wardrobes) do
        if esp and esp.CurrentSettings then
            esp.CurrentSettings.Color = ESPColors.Wardrobe
            if ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillColor = ESPColors.Wardrobe
                esp.CurrentSettings.OutlineColor = ESPColors.Wardrobe
            end
        end
    end
end

function ESPManager:UpdateEntitiesColor()
    for entity, esp in pairs(ESPObjects.Entities) do
        if esp and esp.CurrentSettings then
            esp.CurrentSettings.Color = ESPColors.Entity
            if ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillColor = ESPColors.Entity
                esp.CurrentSettings.OutlineColor = ESPColors.Entity
            end
        end
    end
end

function ESPManager:UpdateItemsColor()
    for item, esp in pairs(ESPObjects.Items) do
        if esp and esp.CurrentSettings then
            esp.CurrentSettings.Color = ESPColors.Items
            if ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillColor = ESPColors.Items
                esp.CurrentSettings.OutlineColor = ESPColors.Items
            end
        end
    end
end

function ESPManager:UpdateChestsColor()
    for chest, esp in pairs(ESPObjects.Chests) do
        if esp and esp.CurrentSettings then
            esp.CurrentSettings.Color = ESPColors.Chest
            if ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillColor = ESPColors.Chest
                esp.CurrentSettings.OutlineColor = ESPColors.Chest
            end
        end
    end
end

function ESPManager:UpdateGoldColor()
    for gold, esp in pairs(ESPObjects.Gold) do
        if esp and esp.CurrentSettings then
            esp.CurrentSettings.Color = ESPColors.Gold
            if ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillColor = ESPColors.Gold
                esp.CurrentSettings.OutlineColor = ESPColors.Gold
            end
        end
    end
end

function ESPManager:UpdateBooksColor()
    for book, esp in pairs(ESPObjects.Books) do
        if esp and esp.CurrentSettings then
            esp.CurrentSettings.Color = ESPColors.Books
            if ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillColor = ESPColors.Books
                esp.CurrentSettings.OutlineColor = ESPColors.Books
            end
        end
    end
end

function ESPManager:UpdateAllTransparency()
    for category, objects in pairs(ESPObjects) do
        for obj, esp in pairs(objects) do
            if esp and esp.CurrentSettings then
                esp.CurrentSettings.Transparency = ESPSettings.Transparency
            end
        end
    end
end

function ESPManager:UpdateAllFillTransparency()
    for category, objects in pairs(ESPObjects) do
        for obj, esp in pairs(objects) do
            if esp and esp.CurrentSettings and ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.FillTransparency = ESPSettings.FillTransparency
            end
        end
    end
end

function ESPManager:UpdateAllOutlineTransparency()
    for category, objects in pairs(ESPObjects) do
        for obj, esp in pairs(objects) do
            if esp and esp.CurrentSettings and ESPSettings.Type == "Highlight" then
                esp.CurrentSettings.OutlineTransparency = ESPSettings.OutlineTransparency
            end
        end
    end
end

function ESPManager:UpdateAllTextSize()
    for category, objects in pairs(ESPObjects) do
        for obj, esp in pairs(objects) do
            if esp and esp.CurrentSettings then
                esp.CurrentSettings.TextSize = ESPSettings.TextSize
            end
        end
    end
end

function ESPManager:UpdateAllLinePosition()
    for player, esp in pairs(ESPObjects.Players) do
        if esp and esp.CurrentSettings and esp.CurrentSettings.Tracer then
            esp.CurrentSettings.Tracer.From = ESPSettings.LinePosition
        end
    end
end

function ESPManager:UpdateAllArrowOffset()
    for player, esp in pairs(ESPObjects.Players) do
        if esp and esp.CurrentSettings and esp.CurrentSettings.Arrow then
            esp.CurrentSettings.Arrow.CenterOffset = ESPSettings.ArrowOffset
        end
    end
end

function ESPManager:RecreateAllESP()
    local states = {}
    for category, _ in pairs(ESPObjects) do
        local toggleName = "ESP" .. category:sub(1, 1):upper() .. category:sub(2)
        states[category] = Toggles[toggleName] and Toggles[toggleName].Value or false
    end
    
    for category, _ in pairs(ESPObjects) do
        local disableFunc = self["Disable" .. category:sub(1, 1):upper() .. category:sub(2) .. "ESP"]
        if disableFunc then
            disableFunc(self)
        end
    end
    
    task.wait(0.2)
    for category, state in pairs(states) do
        if state then
            local enableFunc = self["Enable" .. category:sub(1, 1):upper() .. category:sub(2) .. "ESP"]
            if enableFunc then
                enableFunc(self)
            end
        end
    end
end

LocalPlayer:GetAttributeChangedSignal("CurrentRoom"):Connect(function()
    if Toggles.ESPDoor and Toggles.ESPDoor.Value then
        ESPManager:DisableDoorsESP()
        task.wait(0.1)
        ESPManager:EnableDoorsESP()
    end
    if Toggles.ESPKey and Toggles.ESPKey.Value then
        ESPManager:DisableKeysESP()
        task.wait(0.1)
        ESPManager:EnableKeysESP()
    end
    if Toggles.ESPWardrobe and Toggles.ESPWardrobe.Value then
        ESPManager:DisableWardrobesESP()
        task.wait(0.1)
        ESPManager:EnableWardrobesESP()
    end
end)

workspace.DescendantAdded:Connect(function(descendant)
    if Toggles.ESPKey and Toggles.ESPKey.Value then
        if descendant.Name == "KeyObtain" and not descendant:GetAttribute("Used") then
            task.wait(0.5)
            ESPManager:AddKeyESP(descendant)
        end
    end
    
    if Toggles.ESPEntity and Toggles.ESPEntity.Value then
        local entities = {"RushMoving", "AmbushMoving", "A60", "A120", "Eyes"}
        for _, entityName in ipairs(entities) do
            if descendant.Name == entityName then
                task.wait(0.5)
                ESPManager:AddEntityESP(descendant, entityName)
            end
        end
    end
end)

function Sound()
    local sound = Instance.new("Sound", SoundService)
    sound.Volume = 2.5
    sound.SoundId = "rbxassetid://" .. notifysound 
    sound.Playing = PlayingSound and true or false
    Debris:AddItem(sound, 2)
end

local NotifyMessages = {
    RushMoving = "RushÂ∑≤ÁîüÊàê",
    AmbushMoving = "AmbushÂ∑≤ÁîüÊàê", 
    A60 = "A-60Â∑≤ÁîüÊàê",
    A120 = "A-120Â∑≤ÁîüÊàê",
    Eyes = "EyesÂ∑≤ÁîüÊàê",
    GlitchRush = "GlitchRushÂ∑≤ÁîüÊàê",
    GlitchAmbush = "GlitchAmbushÂ∑≤ÁîüÊàê",
    MonumentEntity = "MonumentÂ∑≤ÁîüÊàê",
    BackdoorRush = "BlitzÂ∑≤ÁîüÊàê",
    BackdoorLookman = "LookmanÂ∑≤ÁîüÊàê",
    Groundskeeper = "Âõ≠‰∏ÅÂ∑≤ÁîüÊàê",
    GrumbleRig = "GrumbleÂ∑≤ÁîüÊàê",
    Screech = "ScreechÂ∑≤ÁîüÊàê",
    Halt = "HaltÂ∑≤ÁîüÊàê",
    FigureRig = "FigureÂ∑≤ÁîüÊàê",
    Snare = "SnareÂ∑≤ÁîüÊàê",
    WorldLotus = "World LotusÂ∑≤ÁîüÊàê",
    Bramble = "BrambleÂ∑≤ÁîüÊàê",
    Caws = "CawsÂ∑≤ÁîüÊàê",
    Eyestalk = "EyestalkÂ∑≤ÁîüÊàê",
    Grampy = "GrampyÂ∑≤ÁîüÊàê",
    Mandrake = "MandrakeÂ∑≤ÁîüÊàê",
    Surge = "SurgeÂ∑≤ÁîüÊàê",
    Dread = "DreadÂ∑≤ÁîüÊàê",
    GloomPile = "GloomËõãÂ∑≤ÁîüÊàê",
    Giggle = "GiggleÂ∑≤ÁîüÊàê"
}

local ChatMessages = {
    RushMoving = "RushÂ∑≤ÁîüÊàê",
    AmbushMoving = "AmbushÂ∑≤ÁîüÊàê",
    A60 = "A-60Â∑≤ÁîüÊàê",
    A120 = "A-120Â∑≤ÁîüÊàê",
    Eyes = "EyesÂ∑≤ÁîüÊàê",
    GlitchRush = "GlitchRushÂ∑≤ÁîüÊàê",
    GlitchAmbush = "GlitchAmbushÂ∑≤ÁîüÊàê",
    MonumentEntity = "MonumentÂ∑≤ÁîüÊàê",
    BackdoorRush = "BlitzÂ∑≤ÁîüÊàê",
    BackdoorLookman = "LookmanÂ∑≤ÁîüÊàê",
    Groundskeeper = "Âõ≠‰∏ÅÂ∑≤ÁîüÊàê",
    GrumbleRig = "GrumbleÂ∑≤ÁîüÊàê",
    Screech = "ScreechÂ∑≤ÁîüÊàê",
    Halt = "HaltÂ∑≤ÁîüÊàê",
    FigureRig = "FigureÂ∑≤ÁîüÊàê",
    Snare = "SnareÂ∑≤ÁîüÊàê",
    WorldLotus = "World LotusÂ∑≤ÁîüÊàê",
    Bramble = "BrambleÂ∑≤ÁîüÊàê",
    Caws = "CawsÂ∑≤ÁîüÊàê",
    Eyestalk = "EyestalkÂ∑≤ÁîüÊàê",
    Grampy = "GrampyÂ∑≤ÁîüÊàê",
    Mandrake = "MandrakeÂ∑≤ÁîüÊàê",
    Surge = "SurgeÂ∑≤ÁîüÊàê",
    Dread = "DreadÂ∑≤ÁîüÊàê",
    GloomPile = "GloomËõãÂ∑≤ÁîüÊàê",
    Giggle = "GiggleÂ∑≤ÁîüÊàê"
}

local EntityTable = {
    RushMoving = "Rush",
    AmbushMoving = "Ambush",
    A60 = "A-60", 
    A120 = "A-120",
    Eyes = "Eyes",
    GlitchRush = "GlitchRush",
    GlitchAmbush = "GlitchAmbush",
    MonumentEntity = "Monument",
    BackdoorRush = "Blitz",
    BackdoorLookman = "Lookman",
    Groundskeeper = "Groundskeeper",
    GrumbleRig = "Grumble",
    Screech = "Screech",
    Halt = "Halt",
    FigureRig = "Figure",
    Snare = "Snare",
    WorldLotus = "WorldLotus",
    Bramble = "Bramble",
    Caws = "Caws",
    Eyestalk = "Eyestalk",
    Grampy = "Grampy",
    Mandrake = "Mandrake",
    Surge = "Surge",
    Dread = "Dread",
    GloomPile = "GloomPile",
    Giggle = "Giggle"
}

local EntityNotifyToggle = NotifySubTab:AddCheckbox('EntityNotifys', {
    Text = "ÂÆû‰ΩìÈÄöÁü•",
    Default = false
})

NotifySettingsSubTab:AddCheckbox('ChatNotify', {
    Text = "ËÅäÂ§©ÈÄöÁü•", 
    Default = false
})

local EntitiesDropdown = NotifySubTab:AddDropdown("EntitiesPicker", {
    Values = { 
        "Rush", "Ambush", "A-60", "A-120", "Bramble", "Grumble", "Eyes", 
        "Lookman", "Blitz", "Figure", "GlitchRush", "GlitchAmbush", 
        "Monument", "Groundskeeper", "Screech", "Halt", "Snare", "WorldLotus",
        "Caws", "Eyestalk", "Grampy", "Mandrake", "Surge", "Dread", "GloomPile", "Giggle"
    },
    Default = 1,
    Multi = true,
    Text = "ÂÆû‰Ωì"
})

local function SendChatMessage(message)
    if Toggles.ChatNotify.Value then
        local SayMessageRequest = ReplicatedStorage:FindFirstChild("SayMessageRequest")
        if SayMessageRequest then
            SayMessageRequest:FireServer(message, "All")
        end
    end
end

workspace.ChildAdded:Connect(function(v)
    if Toggles.EntityNotifys.Value then
        local entityName = EntityTable[v.Name]
        if entityName and Options.EntitiesPicker.Value[entityName] then
            local notifyMessage = NotifyMessages[v.Name] or (entityName .. "Â∑≤ÁîüÊàê")
            Library:Notify(notifyMessage, 3)
            Sound()
            if Toggles.ChatNotify.Value then
                local chatMessage = ChatMessages[v.Name] or (entityName .. "Â∑≤ÁîüÊàê")
                task.spawn(function()
                    task.wait(0.5)
                    SendChatMessage(chatMessage)
                end)
            end
        end
    end
end)

for _, v in ipairs(workspace:GetChildren()) do
    if Toggles.EntityNotifys.Value then
        local entityName = EntityTable[v.Name]
        if entityName and Options.EntitiesPicker.Value[entityName] then
            local notifyMessage = NotifyMessages[v.Name] or (entityName .. "Â∑≤ÁîüÊàê")
            Library:Notify(notifyMessage, 3)
            Sound()
        end
    end
end

local ThirdPerson = {
    Enabled = false,
    Distance = 10,
    CameraOffset = Vector3.new(0, 0, 0),
    OriginalTransparency = {},
    Connection = nil
}

function ThirdPerson:SaveOriginalTransparency(character)
    self.OriginalTransparency = {}
    if character then
        local head = character:FindFirstChild("Head")
        if head then
            self.OriginalTransparency.Head = head.Transparency
        end
        
        for _, accessory in pairs(character:GetChildren()) do
            if accessory:IsA("Accessory") then
                local handle = accessory:FindFirstChild("Handle")
                if handle then
                    self.OriginalTransparency[accessory.Name] = handle.Transparency
                end
            end
        end
    end
end

function ThirdPerson:RestoreOriginalTransparency(character)
    if character and next(self.OriginalTransparency) ~= nil then
        local head = character:FindFirstChild("Head")
        if head and self.OriginalTransparency.Head then
            head.Transparency = self.OriginalTransparency.Head
        end
        
        for _, accessory in pairs(character:GetChildren()) do
            if accessory:IsA("Accessory") and self.OriginalTransparency[accessory.Name] then
                local handle = accessory:FindFirstChild("Handle")
                if handle then
                    handle.Transparency = self.OriginalTransparency[accessory.Name]
                end
            end
        end
    end
end



function ThirdPerson:UpdateCamera()
    if not self.Enabled then return end
    
    local character = LocalPlayer.Character
    local camera = workspace.CurrentCamera
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not character or not camera or not humanoidRootPart then return end
    
    local lookVector = camera.CFrame.LookVector
    local offset = lookVector * -self.Distance + self.CameraOffset
    local targetPosition = humanoidRootPart.Position + offset
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {character}
    
    local raycastResult = workspace:Raycast(
        humanoidRootPart.Position,
        offset,
        raycastParams
    )
    
    if raycastResult then
        local adjustedDistance = (raycastResult.Position - humanoidRootPart.Position).Magnitude - 1
        targetPosition = humanoidRootPart.Position + offset.Unit * math.min(adjustedDistance, self.Distance)
    end
    
    camera.CFrame = CFrame.new(targetPosition, humanoidRootPart.Position)
end

function ThirdPerson:Enable()
    if self.Enabled then return end
    
    self.Enabled = true
    local character = LocalPlayer.Character
    
    self:SaveOriginalTransparency(character)
    
    self.Connection = RunService.RenderStepped:Connect(function()
        self:UpdateCamera()
    end)
    
end

function ThirdPerson:Disable()
    if not self.Enabled then return end
    
    self.Enabled = false
    
    if self.Connection then
        self.Connection:Disconnect()
        self.Connection = nil
    end
    
    local character = LocalPlayer.Character
    self:RestoreOriginalTransparency(character)
    self:SetCharacterTransparency(character, 0)
    
    local camera = workspace.CurrentCamera
    if camera then
        camera.CameraType = Enum.CameraType.Custom
    end
    
end

function ThirdPerson:Toggle()
    if self.Enabled then
        self:Disable()
    else
        self:Enable()
    end
end

function ThirdPerson:SetDistance(distance)
    self.Distance = math.clamp(distance, 3, 30)
end

LocalPlayer.CharacterAdded:Connect(function(character)
    if ThirdPerson.Enabled then
        task.wait(1)
        ThirdPerson:SaveOriginalTransparency(character)
    end
end)

LocalPlayer.CharacterRemoving:Connect(function()
    if ThirdPerson.Enabled then
        ThirdPerson.OriginalTransparency = {}
    end
end)

CameraGroup:AddCheckbox('Thirdperson', {
    Text = 'Á¨¨‰∏â‰∫∫Áß∞ËßÜËßí',
    Default = false,
    Callback = function(Value)
        if Value then
            ThirdPerson:Enable()
        else
            ThirdPerson:Disable()
        end
    end
}):AddKeyPicker('ThirdpersonKey', {
    Default = 'V',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Á¨¨‰∏â‰∫∫Áß∞',
})

CameraGroup:AddSlider('ThirdpersonDistance', {
    Text = 'Á¨¨‰∏â‰∫∫Áß∞Ë∑ùÁ¶ª',
    Default = 10,
    Min = 3,
    Max = 30,
    Rounding = 0,
    Compact = true,
    Callback = function(Value)
        ThirdPerson:SetDistance(Value)
    end
})

CameraGroup:AddCheckbox('NoCutscenes',{
    Text = "Êó†ËøáÂú∫Âä®Áîª", 
    Default = false
})

CameraGroup:AddDivider()

CameraGroup:AddCheckbox('NoCameraShake',{
    Text = "Êó†Áõ∏Êú∫ÊäñÂä®",
    Default = false,
})

RunService.RenderStepped:Connect(function()
    if alive then
        if Toggles.NoCameraShake.Value then
            RequiredMainGame.csgo = CFrame.new()
        end
    end
end)

Toggles.NoCutscenes:OnChanged(function(Value)
    local CutScenes = RemoteListener:FindFirstChild("Cutscenes") or RemoteListener:FindFirstChild("_Cutscenes")
    CutScenes.Name = Value and "_Cutscenes" or "Cutscenes"
end)

local TransparencyValue = 0.5

CameraGroup:AddSlider("TransparencySlider", {
    Text = "ÈÄèÊòéÂ∫¶ÊªëÂùó",
    Default = 0.5,
    Min = 0.1,
    Max = 1,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        TransparencyValue = Value
    end      
})

CameraGroup:AddCheckbox('TransparencyCloset',{
    Text = "ÂçäÈÄèÊòéË∫≤ËóèÁÇπ",
    Default = false
})

Character:GetAttributeChangedSignal("Hiding"):Connect(function()
    if Toggles.TransparencyCloset.Value then
        local isHiding = Character:GetAttribute("Hiding")
        if isHiding then
            for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:GetDescendants()) do
                if v:FindFirstChild("HidePrompt") then
                    if v:FindFirstChild("HiddenPlayer") and v.HiddenPlayer.Value ~= nil then
                        for _, base in ipairs(v:GetChildren()) do
                            if base:IsA("BasePart") and not (base.Name == "PlayerCollision" or base.Name == "Collision") then
                                base.Transparency = TransparencyValue
                            end
                        end
                    end
                end
            end
        else
            for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:GetDescendants()) do
                if v:FindFirstChild("HidePrompt") then
                    for _, base in ipairs(v:GetChildren()) do
                        if base:IsA("BasePart") and not (base.Name == "PlayerCollision" or base.Name == "Collision") then
                            base.Transparency = 0
                        end
                    end
                end
            end
        end
    end
end)

CameraGroup:AddSlider('FOV', {
    Text = 'FOV',
    Default = 70,
    Min = 0,
    Max = 120,
    Rounding = 1,
    Compact = true,
    Callback = function(TargetFOV)
        TargetFOV = math.clamp(TargetFOV, 0, 120)
        local CurrentFOV = workspace.CurrentCamera.FieldOfView or 70
        local Smoothing = 15
        local Threshold = 0.05

        if _G.FOVConnection then
            _G.FOVConnection:Disconnect()
        end

        _G.FOVConnection = RunService.RenderStepped:Connect(function(dt)
            CurrentFOV = CurrentFOV + ((TargetFOV - CurrentFOV) * (1 - math.exp(-Smoothing * dt)))
            if (math.abs(TargetFOV - CurrentFOV) < Threshold) then
                CurrentFOV = TargetFOV
            end
            workspace.CurrentCamera.FieldOfView = CurrentFOV
        end)
    end,
})












_G.originalWalkSpeed = 16
_G.movementLoop = nil
_G.speedhack = false
_G.Character = nil
_G.alive = false
_G.Delay = 0.216
_G.CollisionClone = nil
_G.CollisionClone2 = nil
_G.hitted = false
_G.DoorReachRange = 20
_G.NoAcceleration = {}
_G.NoAcceleration.Enabled = false
_G.NoAcceleration.LoopConnection = nil

function _G.NoAcceleration:Enable()
    if self.Enabled then return end
    self.Enabled = true
    self.LoopConnection = RunService.Heartbeat:Connect(function()
        if not self.Enabled or not LocalPlayer.Character then return end
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local collision = LocalPlayer.Character:FindFirstChild("Collision")
        if rootPart then
            rootPart.CustomPhysicalProperties = PhysicalProperties.new(100, 0.5, 0.2)
        end
        if collision then
            collision.CustomPhysicalProperties = PhysicalProperties.new(100, 0.5, 0.2)
        end
    end)
end

function _G.NoAcceleration:Disable()
    if not self.Enabled then return end
    self.Enabled = false
    if self.LoopConnection then
        self.LoopConnection:Disconnect()
        self.LoopConnection = nil
    end
    if LocalPlayer.Character then
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local collision = LocalPlayer.Character:FindFirstChild("Collision")
        if rootPart then
            rootPart.CustomPhysicalProperties = PhysicalProperties.new(0.4, 0.2, 0.2)
        end
        if collision then
            collision.CustomPhysicalProperties = PhysicalProperties.new(0.4, 0.2, 0.2)
        end
    end
end

function updateMovement()
    if not Player.Character then return end
    local humanoid = Player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    if _G.speedhack then
        humanoid.WalkSpeed = Options.WalkSpeed.Value
    else
        humanoid.WalkSpeed = _G.originalWalkSpeed
    end
end

function startMovementLoop()
    if _G.movementLoop then
        _G.movementLoop:Disconnect()
        _G.movementLoop = nil
    end
    _G.movementLoop = RunService.Heartbeat:Connect(function()
        if _G.speedhack then
            updateMovement()
        end
    end)
end

local function initializeCollisionClones()
    if _G.Character and _G.Character:FindFirstChild("CollisionPart") then
        if _G.Character:FindFirstChild("_CollisionPart") then
            _G.Character:FindFirstChild("_CollisionPart"):Destroy()
        end
        if _G.Character:FindFirstChild("_CollisionPart2") then
            _G.Character:FindFirstChild("_CollisionPart2"):Destroy()
        end

        _G.CollisionClone = _G.Character.CollisionPart:Clone()
        _G.CollisionClone.Parent = _G.Character
        _G.CollisionClone.Massless = true
        _G.CollisionClone.CanCollide = false
        _G.CollisionClone.Name = "_CollisionPart"

        _G.CollisionClone2 = _G.Character.CollisionPart:Clone()
        _G.CollisionClone2.Parent = _G.Character
        _G.CollisionClone2.Massless = true
        _G.CollisionClone2.CanCollide = false
        _G.CollisionClone2.Name = "_CollisionPart2"
    end
end

local function startSpeedBypass()
    while task.wait(_G.Delay) do
        if not RunService.Heartbeat:Wait() then break end

        if _G.alive and _G.CollisionClone and _G.CollisionClone2 and _G.Character then
            if _G.Character:FindFirstChild("CollisionPart") then
                if _G.Character.CollisionPart.Anchored or _G.hitted then
                    _G.CollisionClone.Massless = true
                    _G.CollisionClone2.Massless = true
                    task.wait(0.65)
                else
                    _G.CollisionClone.Massless = true
                    _G.CollisionClone2.Massless = true
                    task.wait(_G.Delay)
                    _G.CollisionClone2.Massless = false
                    _G.CollisionClone.Massless = false
                end
            end
        end
    end
end

local _JumpConnection 
_JumpConnection = UserInputService.JumpRequest:Connect(function()
    if Toggles.InfiniteJump and Toggles.InfiniteJump.Value then
        local character = Players.LocalPlayer.Character
        if character and character:FindFirstChildOfClass("Humanoid") then
            character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

local function setupCharacterEvents()
    LocalPlayer.CharacterAdded:Connect(function(char)
        task.wait(1.5)
        _G.Character = char
        _G.alive = true
        
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            _G.originalWalkSpeed = humanoid.WalkSpeed
            if Options.WalkSpeed then
                Options.WalkSpeed:SetValue(_G.originalWalkSpeed)
            end
        end
        
        if Toggles.EnableJump and Toggles.EnableJump.Value then
            char:SetAttribute("CanJump", true)
        end
        
        initializeCollisionClones()
        coroutine.wrap(startSpeedBypass)()
        
        if _G.speedhack then
            startMovementLoop()
        end
        updateMovement()
    end)

    LocalPlayer.CharacterRemoving:Connect(function()
        _G.alive = false
        _G.originalWalkSpeed = 16
        if _G.movementLoop then
            _G.movementLoop:Disconnect()
            _G.movementLoop = nil
        end
    end)

    if LocalPlayer.Character then
        _G.Character = LocalPlayer.Character
        _G.alive = true
        local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            _G.originalWalkSpeed = humanoid.WalkSpeed
            if Options.WalkSpeed then
                Options.WalkSpeed:SetValue(_G.originalWalkSpeed)
            end
        end
        initializeCollisionClones()
        coroutine.wrap(startSpeedBypass)()
    end
end

setupCharacterEvents()

Toggles.EnableJump:OnChanged(function(Value)
    if _G.Character then
        _G.Character:SetAttribute("CanJump", Value)
    end
end)

Players.LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(1)
    if _G.speedhack then
        startMovementLoop()
    end
    updateMovement()
    
    local humanoid = character:WaitForChild("Humanoid")
    if humanoid then
        humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if not _G.speedhack then 
                _G.originalWalkSpeed = humanoid.WalkSpeed 
            end
        end)
    end
    
    if Toggles.EnableJump and Toggles.EnableJump.Value then
        character:SetAttribute("CanJump", true)
    end
end)

Players.LocalPlayer.CharacterRemoving:Connect(function()
    _G.originalWalkSpeed = 16
    if _G.movementLoop then
        _G.movementLoop:Disconnect()
        _G.movementLoop = nil
    end
end)

Toggles.AntiAFK:OnChanged(function(Value)
    if Value then
        if AntiAFKConnection then
            AntiAFKConnection:Disconnect()
        end
        AntiAFKConnection = Players.LocalPlayer.Idled:Connect(function()
            local VirtualUser = game:GetService("VirtualUser")
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    else
        if AntiAFKConnection then
            AntiAFKConnection:Disconnect()
            AntiAFKConnection = nil
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if Toggles.NoClosetExitDelay and Toggles.NoClosetExitDelay.Value then
        if LocalPlayer.Character and LocalPlayer.Character:GetAttribute("Hiding") == true then
            if LocalPlayer.Character:FindFirstChild("Humanoid") and (LocalPlayer.Character.Humanoid.MoveDirection.Magnitude > 0.5) then
                if ReplicatedStorage:FindFirstChild("RemotesFolder") then
                    ReplicatedStorage.RemotesFolder.CamLock:FireServer()
                end
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if Toggles.DoorReach and Toggles.DoorReach.Value then
        local alive = LocalPlayer:GetAttribute("Alive")
        if alive then
            local Door = workspace.CurrentRooms[ReplicatedStorage.GameData.LatestRoom.Value].Door
            if Door and Door:FindFirstChild("ClientOpen") then
                local Character = LocalPlayer.Character
                if Character and Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (Character.HumanoidRootPart.Position - Door.Door.Position).Magnitude
                    if distance < _G.DoorReachRange then
                        Door.ClientOpen:FireServer()
                    end
                end
            end
        end
    end
    if Toggles.NoClosetExitDelay and Toggles.NoClosetExitDelay.Value then
        if LocalPlayer.Character and LocalPlayer.Character:GetAttribute("Hiding") == true then
            if LocalPlayer.Character:FindFirstChild("Humanoid") and (LocalPlayer.Character.Humanoid.MoveDirection.Magnitude > 0.5) then
                if ReplicatedStorage:FindFirstChild("RemotesFolder") then
                    ReplicatedStorage.RemotesFolder.CamLock:FireServer()
                end
            end
        end
    end
end)
LocalPlayer:GetAttributeChangedSignal("CurrentRoom"):Connect(function()
    if Toggles.PromptClip and Toggles.PromptClip.Value then
        for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
            if v:IsA("ProximityPrompt") then
                v.RequiresLineOfSight = false
            end
        end
    end
end)
workspace.DescendantAdded:Connect(function(v)
    if Toggles.PromptClip and Toggles.PromptClip.Value then
        if v:IsA("ProximityPrompt") then
            v.RequiresLineOfSight = false
        end
    end
end)

local function fireInteract(prompt)
    if not prompt or not prompt:IsA("ProximityPrompt") then return end
    
    if Disable3 then
        prompt:InputHoldBegin()
        prompt:InputHoldEnd(prompt.HoldDuration)
    else
        fireproximityprompt(prompt)
    end
end

RunService.RenderStepped:Connect(function()
    if Toggles.AutoInteract and Toggles.AutoInteract.Value then
        for _, prompt in ipairs(AutoInteractTable) do
            if prompt and prompt.Parent then
                local check = prompt:GetAttribute("Interactions")
                if not check or check < 1 then
                    local Base
                    if prompt.Parent:IsA("BasePart") then
                        Base = prompt.Parent
                    elseif prompt.Parent.Parent and prompt.Parent.Parent:IsA("BasePart") then
                        Base = prompt.Parent.Parent
                    elseif prompt.Parent and prompt.Parent:FindFirstChildWhichIsA("BasePart") then
                        Base = prompt.Parent:FindFirstChildWhichIsA("BasePart")
                    else
                        if prompt.Parent.Parent and prompt.Parent.Parent:FindFirstChildOfClass("BasePart") then
                            Base = prompt.Parent.Parent:FindFirstChildOfClass("BasePart")
                        end
                    end
                    
                    if Base and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (LocalPlayer.Character.HumanoidRootPart.Position - Base.Position).Magnitude
                        if distance < prompt.MaxActivationDistance then
                            if prompt.Parent and prompt.Parent.Name == "GoldPile" and Options.IgnoreList.Value["ÈáëÂ∏Å"] then 
                                return 
                            end
                            if prompt.Parent:GetAttribute("JeffShop") and Options.IgnoreList.Value["Êù∞Â§´ÂïÜÂ∫ó"] then 
                                return 
                            end
                            if prompt.Parent.Parent and prompt.Parent.Parent.Name == "Drops" and Options.IgnoreList.Value["‰∏¢ÂºÉÁâ©"] then 
                                return 
                            end
                            if prompt.Parent and prompt.Parent.Name == "Bandage" and Options.IgnoreList.Value["Áª∑Â∏¶"] then 
                                return 
                            end
                            if prompt.Parent and prompt.Parent.Name == "ChestBox" and Options.IgnoreList.Value["ÁÆ±Â≠ê"] then 
                                return 
                            end
                            if prompt.Parent and prompt.Parent.Name == "Battery" and Options.IgnoreList.Value["ÁîµÊ±†"] then 
                                return 
                            end
                            if prompt.Name == "ModulePrompt" and prompt.Parent and prompt.Parent.Name == "Hole" then 
                                return 
                            end
                            if prompt.Name == "ModulePrompt" and prompt.Parent and prompt.Parent.Name == "Mandrake" then 
                                return 
                            end
                            if prompt.Parent and prompt.Parent.Name == "Padlock" then 
                                return 
                            end

                            if prompt.ClickablePrompt then
                                fireInteract(prompt)
                            end
                        end
                    end
                end
            end
        end
    end
end)

workspace.DescendantAdded:Connect(function(v)
    if Toggles.AutoInteract and Toggles.AutoInteract.Value then
        if v:IsA("ProximityPrompt") then
            if not Ignore[v.Name] then
                table.insert(AutoInteractTable, v)
            end
        end
    end
end)

local Prompt = Instance.new("ProximityPrompt", workspace)
Prompt.Name = "TestPrompt"

local success, result = pcall(function()
    return fireproximityprompt(Prompt)
end)
if not success then
    Prompt:Destroy()
    Disable3 = true
end
Prompt:Destroy()

local old
old = hookmetamethod(game,"__namecall",newcclosure(function(self, ...)
local args = { ... }
local method = getnamecallmethod()

if self.Name == "ClutchHeartbeat" and method == "FireServer" and Toggles.AutoHeartbeat.Value then
args[1] = true
return old(self,unpack(args))

end

return old(self, ...)
end))

local Breaker = nil

task.spawn(function()
    while true do
        task.wait()
        if not Toggles.AutoBreakerBox.Value then break end
        if Breaker then
            for _, v in ipairs(Breaker:GetChildren()) do
                if v.Name == "BreakerSwitch" then
                    if v:GetAttribute("ID") == tonumber(Breaker:WaitForChild("SurfaceGui").Frame.Code.Text) then
                        if Breaker:WaitForChild("SurfaceGui").Frame.Code.Frame.BackgroundTransparency == 0 then
                            v:SetAttribute("Enabled", true)
                            if v:WaitForChild("Sound").Playing == false then
                                v:WaitForChild("Sound", 1e1).Playing = true
                            end
                            v.Material = Enum.Material.Neon
                            v:WaitForChild("Light", 1e1).Attachment.Spark:Emit(1)
                            v:WaitForChild("PrismaticConstraint").TargetPosition = -0.2
                        else
                            v:SetAttribute("Enabled", false)
                            if v:WaitForChild("Sound").Playing == false then
                                v:WaitForChild("Sound", 1e1).Playing = true
                            end
                            v:WaitForChild("PrismaticConstraint").TargetPosition = 0.2
                            v.Material = Enum.Material.Glass
                        end
                    end
                end
            end
        end
    end
end)
workspace.DescendantAdded:Connect(function(v)
    if v.Name == "ElevatorBreaker" then
        Breaker = v
    end
end)
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
    if v.Name == "ElevatorBreaker" then
        Breaker = v
    end
end

RunService.RenderStepped:Connect(function()
    if Toggles.AntiEyes and Toggles.AntiEyes.Value then
        local alive = LocalPlayer:GetAttribute("Alive")
        if alive then
            if Workspace:FindFirstChild("Eyes") then
                RemoteFolder.MotorReplication:FireServer(-890)
            end
        end
    end
end)
Toggles.AntiFigure:OnChanged(function(Value)
    if not Value then
        RemoteFolder.Crouch:FireServer(false)
    end
end)

RunService.RenderStepped:Connect(function()
    if Toggles.AntiHear and Toggles.AntiHear.Value then
        RemoteFolder.Crouch:FireServer(true)
    end
end)

LocalPlayer:GetAttributeChangedSignal("CurrentRoom"):Connect(function()
    if Toggles.AntiSnare and Toggles.AntiSnare.Value then
        for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
            if room:FindFirstChild("Snares") then
                for _, v in ipairs(room.Snares:GetChildren()) do
                    if v.Name == "Snare" then
                        v:WaitForChild("Hitbox", 9e9).CanTouch = false
                    end
                end
            end
        end
    end

    if Toggles.AntiDupe and Toggles.AntiDupe.Value then
        for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:GetChildren()) do
            if v and v.Name == "SideroomDupe" then
                v:WaitForChild("DoorFake", 9e9):WaitForChild("Hidden", 9e9).CanTouch = false
                if v:WaitForChild("DoorFake"):FindFirstChild("Lock") then
                    v:WaitForChild("DoorFake"):FindFirstChild("Lock"):FindFirstChildOfClass("ProximityPrompt").ClickablePrompt = false
                end
            end
        end
    end
end)
function GetNearestCloset()
    local closest = nil
    local MaxDistance = math.huge
    for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:FindFirstChild("Assets", true):GetChildren()) do
        if v.Name == "Wardrobe" or v.Name == "Rooms_Locker" or v.Name == "Rooms_Locker_Fridge" or v.Name == "Toolshed" or v.Name == "Locker_Large" or v.Name == "Backdoor_Wardrobe" or v.Name == "Bed" or v.Name == "Double_Bed" then
            if not v.Main:FindFirstChild("HideEntityOnSpot") then
                if v.PrimaryPart then
                    local Distance = (LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude
                    if Distance < MaxDistance then
                        closest = v
                        MaxDistance = Distance 
                    end
                end
            end
        end
    end
    return closest
end

RunService.RenderStepped:Connect(function()
    if Toggles.AutoCloset and Toggles.AutoCloset.Value then
        local Closet = GetNearestCloset()
        for _, v in ipairs(workspace:GetChildren()) do
            local range = EntitysTable[v.Name]
            if range and v.PrimaryPart then
                if (LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude <= range then 
                    if Closet then
                        if not LocalPlayer.Character.CollisionPart.Anchored then
                            fireInteract(Closet:WaitForChild("HidePrompt"))
                        end
                    end
                elseif (LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude > range then 
                    LocalPlayer.Character:SetAttribute("Hiding", false)
                    if not v:GetAttribute("Destroying") then
                        v:SetAttribute("Destroying", true)
                        v.Destroying:Connect(function()
                            LocalPlayer.Character:SetAttribute("Hiding", false)
                        end)
                    end
                end
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if Toggles.AnticheatManipulation and Toggles.AnticheatManipulation.Value then
        local alive = LocalPlayer:GetAttribute("Alive")
        if alive then
            if LocalPlayer.Character then
                LocalPlayer.Character:PivotTo(LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 10000))
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if Toggles.GodMode and Toggles.GodMode.Value then
        LocalPlayer.Character.Collision.CollisionCrouch.CanCollide = false
    end
end)


function ESPManager:Enable()
    self:Disable()
    
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            self:AddPlayer(player)
        end
    end
    
    self.Connections.PlayerAdded = game.Players.PlayerAdded:Connect(function(player)
        if player ~= game.Players.LocalPlayer then
            self:AddPlayer(player)
        end
    end)
    
    self.Connections.PlayerRemoving = game.Players.PlayerRemoving:Connect(function(player)
        self:RemovePlayer(player)
    end)
end

function ESPManager:Disable()
    for player, esp in pairs(self.Players) do
        if esp then 
            pcall(function() 
                esp:Destroy() 
            end) 
        end
    end
    self.Players = {}
    
    for _, conn in pairs(self.Connections) do
        pcall(function() 
            conn:Disconnect() 
        end)
    end
    self.Connections = {}
end

function ESPManager:AddPlayer(player)
    if self.Players[player] then 
        return 
    end
    
    if Settings.TeamCheck then
        local localPlayer = game.Players.LocalPlayer
        if player.Team and localPlayer.Team and player.Team == localPlayer.Team then
            return
        end
    end
    
    local function setupESP(character)
        if not character or not character:IsDescendantOf(workspace) then 
            return 
        end
        
        pcall(function()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
            if not humanoidRootPart then 
                return 
            end
            
            local espColor = Settings.Color
            if Settings.TeamColor then
                if player.Team then
                    espColor = player.Team.TeamColor.Color
                end
            end
            
            local espSettings = {
                Name = player.Name,
                Model = character,
                Color = espColor,
                MaxDistance = 5000,
                TextSize = Settings.TextSize,
                ESPType = Settings.Type,
                FillColor = espColor,
                OutlineColor = espColor,
                FillTransparency = Settings.FillTransparency,
                OutlineTransparency = Settings.OutlineTransparency,
                Transparency = Settings.Transparency
            }
            
            if Settings.ShowLines then
                espSettings.Tracer = {
                    Enabled = true,
                    Color = espColor,
                    From = Settings.LinePosition,
                    Thickness = 2,
                    Transparency = 0
                }
            end
            
            if Settings.ShowArrows then
                espSettings.Arrow = {
                    Enabled = true,
                    Color = espColor,
                    CenterOffset = Settings.ArrowOffset
                }
            end
            
            local esp = ESPLibrary:Add(espSettings)
            self.Players[player] = esp
        end)
    end
    
    if player.Character then 
        setupESP(player.Character) 
    end
    
    self.Connections[player] = player.CharacterAdded:Connect(setupESP)
end

function ESPManager:RemovePlayer(player)
    if self.Players[player] then
        pcall(function() 
            self.Players[player]:Destroy() 
        end)
        self.Players[player] = nil
    end
    
    if self.Connections[player] then
        pcall(function() 
            self.Connections[player]:Disconnect() 
        end)
        self.Connections[player] = nil
    end
end

function ESPManager:UpdateAllPlayers()
    if not self.Enabled then 
        return 
    end
    
    for player, esp in pairs(self.Players) do
        if esp and esp.CurrentSettings then
            pcall(function()
                local espColor = Settings.Color
                if Settings.TeamColor and player.Team then
                    espColor = player.Team.TeamColor.Color
                end
                
                esp.CurrentSettings.Color = espColor
                esp.CurrentSettings.FillColor = espColor
                esp.CurrentSettings.OutlineColor = espColor
                esp.CurrentSettings.TextSize = Settings.TextSize
                esp.CurrentSettings.Transparency = Settings.Transparency
                esp.CurrentSettings.FillTransparency = Settings.FillTransparency
                esp.CurrentSettings.OutlineTransparency = Settings.OutlineTransparency
            end)
        end
    end
end

function ESPManager:RecreateAllPlayers()
    if not self.Enabled then 
        return 
    end
    
    local wasEnabled = self.Enabled
    self:Disable()
    
    if wasEnabled then
        task.wait(0.1)
        self:Enable()
    end
end

function ESPManager:UpdateArrowOffsets(offset)
    if not self.Enabled then 
        return 
    end
    
    for player, esp in pairs(self.Players) do
        if esp and esp.CurrentSettings and esp.CurrentSettings.Arrow then
            pcall(function()
                esp.CurrentSettings.Arrow.CenterOffset = offset
            end)
        end
    end
end

local AntiSeekObstaclesToggle = FloorAntiEntityGroup:AddCheckbox("AntiSeekObstacles", {
    Text = "Èò≤SeekÈöúÁ¢ç",
    Default = false,
    Callback = function(Value)
        local Rooms = workspace.CurrentRooms
        
        if Value then
            AntiConnections['SeekArmsChandelier'] = Rooms.DescendantAdded:Connect(function(desc)
                if desc.Name == 'Seek_Arm' then
                    desc:WaitForChild('AnimatorPart', 8999999488)
                    desc.AnimatorPart.CanTouch = false
                    desc.AnimatorPart.Transparency = 1

                    for _, part in desc:GetDescendants() do
                        if part:IsA('BasePart') then
                            part.Transparency = 1
                        end
                    end
                elseif desc.Name == 'ChandelierObstruction' then
                    desc:WaitForChild('HurtPart', 8999999488)
                    desc.HurtPart.CanTouch = false
                    desc.HurtPart.Transparency = 1

                    for _, part in desc:GetDescendants() do
                        if part:IsA('BasePart') then
                            part.Transparency = 1
                        end
                    end
                elseif desc.Name == 'SeekFloodline' then
                    if desc:IsA('BasePart') then
                        desc.CanCollide = true
                    end
                end
            end)

            for _, v in Rooms:GetDescendants() do
                if v.Name == 'Seek_Arm' and v:IsA('Model') then
                    v:WaitForChild('AnimatorPart', 8999999488)
                    v.AnimatorPart.CanTouch = false
                    v.AnimatorPart.Transparency = 1

                    for _, part in v:GetDescendants() do
                        if part:IsA('BasePart') then
                            part.Transparency = 1
                        end
                    end
                elseif v.Name == 'ChandelierObstruction' and v:IsA('Model') then
                    v:WaitForChild('HurtPart', 8999999488)
                    v.HurtPart.CanTouch = false
                    v.HurtPart.Transparency = 1

                    for _, part in v:GetDescendants() do
                        if part:IsA('BasePart') then
                            part.Transparency = 1
                        end
                    end
                elseif v.Name == 'SeekFloodline' then
                    if v:IsA('BasePart') then
                        v.CanCollide = true
                    end
                end
            end
            
        else
            if AntiConnections['SeekArmsChandelier'] then
                AntiConnections['SeekArmsChandelier']:Disconnect()
            end
            for _, v in Rooms:GetDescendants() do
                if v.Name == 'Seek_Arm' and v:IsA('Model') then
                    v:WaitForChild('AnimatorPart', 8999999488)
                    v.AnimatorPart.CanTouch = true
                    v.AnimatorPart.Transparency = 0

                    for _, part in v:GetDescendants() do
                        if part:IsA('BasePart') then
                            part.Transparency = 0
                        end
                    end
                elseif v.Name == 'ChandelierObstruction' and v:IsA('Model') then
                    v:WaitForChild('HurtPart', 8999999488)
                    v.HurtPart.CanTouch = true
                    v.HurtPart.Transparency = 0

                    for _, part in v:GetDescendants() do
                        if part:IsA('BasePart') then
                            part.Transparency = 0
                        end
                    end
                elseif v.Name == 'SeekFloodline' then
                    if v:IsA('BasePart') then
                        v.CanCollide = false
                    end
                end
            end
        end
    end
})

FloorAntiEntityGroup:AddCheckbox('NoVoidEffect', {
    Text = 'Êó†ËôöÁ©∫ÊïàÊûú',
    Default = false,
    Callback = function(Value)
        local ReplicatedStorage = game:GetService('ReplicatedStorage')
        local entityModules = ReplicatedStorage:FindFirstChild('ModulesClient') and ReplicatedStorage.ModulesClient:FindFirstChild('EntityModules')

        if not entityModules then
            return
        end

        local voidModule = entityModules:FindFirstChild('Void') or entityModules:FindFirstChild('_Void')

        if not voidModule then
            return
        end
        
        if Value then
            if voidModule.Name == 'Void' then
                voidModule.Name = '_Void'
            end
        else
            if voidModule.Name == '_Void' then
                voidModule.Name = 'Void'
            end
        end
    end
})

FloorAntiEntityGroup:AddCheckbox('NoHasteEffects', {
    Text = 'Êó†hasteÊïàÊûú',
    Default = false,
    Callback = function(Value)
        if game.ReplicatedStorage.FloorReplicated.ClientRemote:FindFirstChild('Haste') then
            local HasteChanged = game.ReplicatedStorage.FloorReplicated.ClientRemote.Haste.Ambience:GetPropertyChangedSignal('Playing'):Connect(function()
                if Value then
                    game.ReplicatedStorage.FloorReplicated.ClientRemote.Haste.Ambience.Playing = false
                end
            end)
        end

        for _, v in workspace.CurrentCamera:GetChildren() do
            if v.Name == 'LiveSanity' and workspace:FindFirstChild('EntityModel') then
                v.Enabled = not Value
            end
        end
    end
})

MiscFloorGroup:AddButton('EnableStarrift', {
    Text = 'ÂêØÁî®ÊòüË£Ç',
    Func = function()
        local lighting = game:GetService('Lighting')
        local currentRooms = workspace:FindFirstChild('CurrentRooms')

        if not currentRooms then
            Library:Notify('ÊòüË£ÇÊú™ÊâæÂà∞', 2, notifysound)
            return
        end

        local found = false

        for _, room in ipairs(currentRooms:GetChildren()) do
            local riftSpawn = room:FindFirstChild('RiftSpawn')
            if riftSpawn then
                local rift = riftSpawn:FindFirstChild('Rift')
                if rift then
                    local starCenter = rift:FindFirstChild('StarCenter')
                    if starCenter then
                        found = true
                        local innerRift = starCenter:FindFirstChild('Rift')
                        if innerRift and innerRift:IsA('BasePart') then
                            innerRift.Transparency = 0
                        end

                        local prompt = starCenter:FindFirstChild('StarRiftPrompt')
                        if prompt and prompt:IsA('ProximityPrompt') then
                            prompt.Enabled = true
                        end

                        local attachment = starCenter:FindFirstChild('Attachment')
                        if attachment then
                            local light = attachment:FindFirstChildOfClass('PointLight')
                            if light then
                                light.Brightness = 1
                            end
                        end

                        local particles = starCenter:FindFirstChild('ParticlesIn')
                        if particles then
                            for _, name in ipairs({'Core', 'RainbowShards', 'Triangles', 'ZoomParticle'}) do
                                local emitter = particles:FindFirstChild(name)
                                if emitter and emitter:IsA('ParticleEmitter') then
                                    emitter.Enabled = true
                                end
                            end
                        end
                    end
                end
            end
        end

        if not found then
            Library:Notify('ÊòüË£ÇÊú™ÊâæÂà∞', 2, notifysound)
        else
            Library:Notify('ÊòüË£ÇÂ∑≤ÂêØÁî®', 3, notifysound)
        end
    end
})

MiscFloorGroup:AddButton('GetGlitchCube', {
    Text = 'Ëé∑ÂèñÊïÖÈöúÁ´ãÊñπ‰Ωì',
    Func = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild('HumanoidRootPart')
        local interval = 1
        local studsPerMove = 10
        local downPerMove = 4
        local progress = 0
        local maxProgress = 100
        local progressIncrement = 20
        local ReplicatedStorage = game:GetService('ReplicatedStorage')
        local Players = game:GetService('Players')
        local glitchModule = ReplicatedStorage.ModulesClient.EntityModules.Glitch
        local glitchModel = ReplicatedStorage.Entities.Glitch
        local glitchScreen = player.PlayerGui.MainUI.MainFrame.GlitchScreen
        local isMoving = true
        local glitchActive = false

        local function onGlitchDetected()
            if not glitchActive and progress < maxProgress then
                glitchActive = true
                progress = progress + progressIncrement
                Library:Notify(progress .. '% ÂÆåÊàê', 2, notifysound)
                if progress >= maxProgress then
                    isMoving = false
                    Library:Notify('ÂÆåÊàê„ÄÇÁßªÂä®Â∑≤ÂÅúÊ≠¢„ÄÇ', 3, notifysound)
                end
                task.wait(2)
                glitchActive = false
            end
        end

        local function monitorGlitchScreen()
            glitchScreen:GetPropertyChangedSignal('Visible'):Connect(function()
                if glitchScreen.Visible then
                    onGlitchDetected()
                end
            end)
        end

        local function monitorGlitchModel()
            glitchModel.ChildAdded:Connect(function(child)
                if child.Name == 'Glitch' then
                    onGlitchDetected()
                end
            end)
        end

        pcall(monitorGlitchScreen)
        pcall(monitorGlitchModel)
        
        task.spawn(function()
            while isMoving do
                if character and character.Parent and hrp and hrp.Parent then
                    hrp.CFrame = hrp.CFrame * CFrame.new(-studsPerMove, -downPerMove, 0)
                else
                    character = player.Character or player.CharacterAdded:Wait()
                    hrp = character:WaitForChild('HumanoidRootPart')
                end
                task.wait(interval)
            end
        end)
        
        player.CharacterAdded:Connect(function(newCharacter)
            character = newCharacter
            hrp = character:WaitForChild('HumanoidRootPart')
        end)

        Library:Notify('ÂºÄÂßãËé∑ÂèñÊïÖÈöúÁ´ãÊñπ‰Ωì...', 3, notifysound)
    end
})

MiscFloorGroup:AddButton('GetNVCS3000', {
    Text = 'Ëé∑ÂèñNVCS-3000',
    Func = function()
        _G.scanner_fps = 60
        _G.disable_static = false
        loadstring(game:HttpGet('https://raw.githubusercontent.com/notpoiu/Scripts/main/Scanner.lua'))()
        Library:Notify('NVCS-3000 Â∑≤Âä†ËΩΩ', 3, notifysound)
    end
})

MiscFloorGroup:AddButton('SpeedrunTimer', {
    Text = 'ÈÄüÈÄöËÆ°Êó∂Âô®',
    Func = function()
        if getgenv().SpeedrunTimerActive then
            Library:Notify('ÈÄüÈÄöËÆ°Êó∂Âô®Â∑≤Âú®ËøêË°å', 2, notifysound)
            return
        end

        getgenv().SpeedrunTimerActive = true

        local player = game.Players.LocalPlayer
        local playerGui = player:WaitForChild('PlayerGui', 5)

        if not playerGui then
            return
        end

        local screenGui = Instance.new('ScreenGui')
        screenGui.Name = 'SpeedrunTimerGui'
        screenGui.Parent = playerGui

        local textButton = Instance.new('TextButton')
        textButton.Name = 'TimerButton'
        textButton.Size = UDim2.new(0.2, 0, 0.05, 0)
        textButton.Position = UDim2.new(0.4, 0, 0.02, 0)
        textButton.Text = '00:00:00.000'
        textButton.TextSize = 14
        textButton.BackgroundTransparency = 0.5
        textButton.BackgroundColor3 = Color3.new(0, 0, 0)
        textButton.TextColor3 = Color3.new(1, 1, 1)
        textButton.Parent = screenGui

        local startTime = tick()

        local timerConnection = game:GetService('RunService').Heartbeat:Connect(function()
            if not textButton or not textButton.Parent then
                timerConnection:Disconnect()
                return
            end

            local elapsed = tick() - startTime
            local hours = math.floor(elapsed / 3600)
            elapsed = elapsed % 3600
            local minutes = math.floor(elapsed / 60)
            local seconds = math.floor(elapsed % 60)
            local milliseconds = math.floor((elapsed % 1) * 1000)

            textButton.Text = string.format('%02d:%02d:%02d.%03d', hours, minutes, seconds, milliseconds)
        end)

        getgenv().SpeedrunTimer = {
            Gui = screenGui,
            Connection = timerConnection,
            Stop = function()
                if timerConnection then
                    timerConnection:Disconnect()
                end
                if screenGui then
                    screenGui:Destroy()
                end
                getgenv().SpeedrunTimerActive = false
            end
        }

        Library:Notify('ÈÄüÈÄöËÆ°Êó∂Âô®Â∑≤ÂêØÂä®', 3, notifysound)
    end
})

MiscFloorGroup:AddButton('StopSpeedrunTimer', {
    Text = 'ÂÅúÊ≠¢ÈÄüÈÄöËÆ°Êó∂Âô®',
    Func = function()
        if getgenv().SpeedrunTimer and getgenv().SpeedrunTimer.Stop then
            getgenv().SpeedrunTimer:Stop()
            Library:Notify('ÈÄüÈÄöËÆ°Êó∂Âô®Â∑≤ÂÅúÊ≠¢', 3, notifysound)
        else
            Library:Notify('Ê≤°ÊúâËøêË°åÁöÑÈÄüÈÄöËÆ°Êó∂Âô®', 2, notifysound)
        end
    end
})









Library.OnUnload = function()
    if AntiAFKConnection then
        AntiAFKConnection:Disconnect()
        AntiAFKConnection = nil
    end
    if _JumpConnection then
        _JumpConnection:Disconnect()
        _JumpConnection = nil
    end
    if Noclip.Connection then
        Noclip.Connection:Disconnect()
        Noclip.Connection = nil
    end
    if Fly.Connection then
        Fly.Connection:Disconnect()
        Fly.Connection = nil
    end
    Fly.Cleanup()
    Noclip.Disable()
    if PromptClipConnection then
        PromptClipConnection:Disconnect()
        PromptClipConnection = nil
    end
end

devGroup:AddLabel('[<font color="rgb(255, 0, 0)">Tu</font>] ‰∏ªË¶ÅÂºÄÂèëÂëò')
devGroup:AddLabel('[<font color="rgb(255, 221, 0)">Âç°Âç°Â§ßÁéã</font>] ‰∏ªË¶ÅÁÆ°ÁêÜÂëò')

Library:Notify({
    Title = "yezx Hub",
    Description = "ËÑöÊú¨Âä†ËΩΩÂÆåÊàêÔºÅÂπ≥Âè∞: " .. (IsMobile and "ÊâãÊú∫" or "ÁîµËÑë"),
    SoundId = notifysound,
    Time = 3
})
